/* automatically generated by rust-bindgen 0.60.1 */

pub const LIBLEPT_MAJOR_VERSION: u32 = 1;
pub const LIBLEPT_MINOR_VERSION: u32 = 83;
pub const LIBLEPT_PATCH_VERSION: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HAVE_LIBJPEG: u32 = 1;
pub const HAVE_LIBTIFF: u32 = 1;
pub const HAVE_LIBPNG: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LIBGIF: u32 = 0;
pub const HAVE_LIBUNGIF: u32 = 0;
pub const HAVE_LIBWEBP: u32 = 0;
pub const HAVE_LIBWEBP_ANIM: u32 = 0;
pub const HAVE_LIBJP2K: u32 = 0;
pub const USE_BMPIO: u32 = 1;
pub const USE_PNMIO: u32 = 1;
pub const USE_JP2KHEADER: u32 = 1;
pub const USE_PDFIO: u32 = 1;
pub const USE_PSIO: u32 = 1;
pub const HAVE_FMEMOPEN: u32 = 1;
pub const HAVE_FSTATAT: u32 = 0;
pub const HAVE_DIRFD: u32 = 0;
pub const UNDEF: i32 = -1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const USE_INLINE_ACCESSORS: u32 = 1;
pub const DEWARP_VERSION_NUMBER: u32 = 4;
pub const GPLOT_VERSION_NUMBER: u32 = 1;
pub const NUM_GPLOT_STYLES: u32 = 5;
pub const NUM_GPLOT_OUTPUTS: u32 = 6;
pub const JB_TEMPLATE_EXT: &[u8; 15usize] = b".templates.png\0";
pub const JB_DATA_EXT: &[u8; 6usize] = b".data\0";
pub const SEL_VERSION_NUMBER: u32 = 1;
pub const KERNEL_VERSION_NUMBER: u32 = 2;
pub const PIX_SRC: u32 = 12;
pub const PIX_DST: u32 = 10;
pub const PIX_CLR: u32 = 0;
pub const PIX_SET: u32 = 15;
pub const PIX_PAINT: u32 = 14;
pub const PIX_MASK: u32 = 8;
pub const PIX_XOR: u32 = 6;
pub const RECOG_VERSION_NUMBER: u32 = 2;
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    fn test_field___value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value64)
            )
        );
    }
    test_field___value64();
    fn test_field___value32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value32)
            )
        );
    }
    test_field___value32();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___rwelision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
    }
    test_field___rwelision();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__once_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__once_flag),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___old_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__old_x)
            )
        );
    }
    test_field___old_x();
    fn test_field___c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__c)
            )
        );
    }
    test_field___c();
    fn test_field___init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__init)
            )
        );
    }
    test_field___init();
    fn test_field___a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__a)
            )
        );
    }
    test_field___a();
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: size_t);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::std::os::raw::c_uint;
extern "C" {
    pub fn atomic_thread_fence(arg1: memory_order);
}
extern "C" {
    pub fn atomic_signal_fence(arg1: memory_order);
}
pub type atomic_bool = u8;
pub type atomic_char = u8;
pub type atomic_schar = u8;
pub type atomic_uchar = u8;
pub type atomic_short = u16;
pub type atomic_ushort = u16;
pub type atomic_int = u32;
pub type atomic_uint = u32;
pub type atomic_long = u64;
pub type atomic_ulong = u64;
pub type atomic_llong = u64;
pub type atomic_ullong = u64;
pub type atomic_char16_t = u16;
pub type atomic_char32_t = u32;
pub type atomic_wchar_t = u32;
pub type atomic_int_least8_t = u8;
pub type atomic_uint_least8_t = u8;
pub type atomic_int_least16_t = u16;
pub type atomic_uint_least16_t = u16;
pub type atomic_int_least32_t = u32;
pub type atomic_uint_least32_t = u32;
pub type atomic_int_least64_t = u64;
pub type atomic_uint_least64_t = u64;
pub type atomic_int_fast8_t = u8;
pub type atomic_uint_fast8_t = u8;
pub type atomic_int_fast16_t = u64;
pub type atomic_uint_fast16_t = u64;
pub type atomic_int_fast32_t = u64;
pub type atomic_uint_fast32_t = u64;
pub type atomic_int_fast64_t = u64;
pub type atomic_uint_fast64_t = u64;
pub type atomic_intptr_t = u64;
pub type atomic_uintptr_t = u64;
pub type atomic_size_t = u64;
pub type atomic_ptrdiff_t = u64;
pub type atomic_intmax_t = u64;
pub type atomic_uintmax_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_flag {
    pub _Value: atomic_bool,
}
#[test]
fn bindgen_test_layout_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(atomic_flag))
    );
    fn test_field__Value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<atomic_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._Value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(atomic_flag),
                "::",
                stringify!(_Value)
            )
        );
    }
    test_field__Value();
}
extern "C" {
    pub fn atomic_flag_test_and_set(arg1: *mut atomic_flag) -> bool;
}
extern "C" {
    pub fn atomic_flag_test_and_set_explicit(arg1: *mut atomic_flag, arg2: memory_order) -> bool;
}
extern "C" {
    pub fn atomic_flag_clear(arg1: *mut atomic_flag);
}
extern "C" {
    pub fn atomic_flag_clear_explicit(arg1: *mut atomic_flag, arg2: memory_order);
}
pub type l_atomic = atomic_int;
pub type l_intptr_t = isize;
pub type l_uintptr_t = usize;
pub type l_ok = ::std::os::raw::c_int;
pub type l_int8 = ::std::os::raw::c_schar;
pub type l_uint8 = ::std::os::raw::c_uchar;
pub type l_int16 = ::std::os::raw::c_short;
pub type l_uint16 = ::std::os::raw::c_ushort;
pub type l_int32 = ::std::os::raw::c_int;
pub type l_uint32 = ::std::os::raw::c_uint;
pub type l_float32 = f32;
pub type l_float64 = f64;
pub type l_int64 = ::std::os::raw::c_longlong;
pub type l_uint64 = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut LeptDebugOK: l_int32;
}
pub const L_NOT_FOUND: _bindgen_ty_1 = 0;
pub const L_FOUND: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const UNIX_PATH_SEPCHAR: _bindgen_ty_2 = 0;
pub const WIN_PATH_SEPCHAR: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type L_TIMER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WallTimer {
    pub start_sec: l_int32,
    pub start_usec: l_int32,
    pub stop_sec: l_int32,
    pub stop_usec: l_int32,
}
#[test]
fn bindgen_test_layout_L_WallTimer() {
    assert_eq!(
        ::std::mem::size_of::<L_WallTimer>(),
        16usize,
        concat!("Size of: ", stringify!(L_WallTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WallTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(L_WallTimer))
    );
    fn test_field_start_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WallTimer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WallTimer),
                "::",
                stringify!(start_sec)
            )
        );
    }
    test_field_start_sec();
    fn test_field_start_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WallTimer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_usec) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WallTimer),
                "::",
                stringify!(start_usec)
            )
        );
    }
    test_field_start_usec();
    fn test_field_stop_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WallTimer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stop_sec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WallTimer),
                "::",
                stringify!(stop_sec)
            )
        );
    }
    test_field_stop_sec();
    fn test_field_stop_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WallTimer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stop_usec) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WallTimer),
                "::",
                stringify!(stop_usec)
            )
        );
    }
    test_field_stop_usec();
}
pub type L_WALLTIMER = L_WallTimer;
pub const L_SEVERITY_EXTERNAL: _bindgen_ty_3 = 0;
pub const L_SEVERITY_ALL: _bindgen_ty_3 = 1;
pub const L_SEVERITY_DEBUG: _bindgen_ty_3 = 2;
pub const L_SEVERITY_INFO: _bindgen_ty_3 = 3;
pub const L_SEVERITY_WARNING: _bindgen_ty_3 = 4;
pub const L_SEVERITY_ERROR: _bindgen_ty_3 = 5;
pub const L_SEVERITY_NONE: _bindgen_ty_3 = 6;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut LeptMsgSeverity: l_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numa {
    _unused: [u8; 0],
}
pub type NUMA = Numa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numaa {
    _unused: [u8; 0],
}
pub type NUMAA = Numaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dna {
    _unused: [u8; 0],
}
pub type L_DNA = L_Dna;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dnaa {
    _unused: [u8; 0],
}
pub type L_DNAA = L_Dnaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_DnaHash {
    _unused: [u8; 0],
}
pub type L_DNAHASH = L_DnaHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sarray {
    _unused: [u8; 0],
}
pub type SARRAY = Sarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bytea {
    _unused: [u8; 0],
}
pub type L_BYTEA = L_Bytea;
pub const L_LINEAR_INTERP: _bindgen_ty_4 = 1;
pub const L_QUADRATIC_INTERP: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const L_CONTINUED_BORDER: _bindgen_ty_5 = 1;
pub const L_SLOPE_BORDER: _bindgen_ty_5 = 2;
pub const L_MIRRORED_BORDER: _bindgen_ty_5 = 3;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const L_INTEGER_VALUE: _bindgen_ty_6 = 1;
pub const L_FLOAT_VALUE: _bindgen_ty_6 = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_ByteBuffer {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub nwritten: l_int32,
    pub array: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_ByteBuffer() {
    assert_eq!(
        ::std::mem::size_of::<L_ByteBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(L_ByteBuffer))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_ByteBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_ByteBuffer),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_ByteBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_ByteBuffer),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_nwritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_ByteBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nwritten) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_ByteBuffer),
                "::",
                stringify!(nwritten)
            )
        );
    }
    test_field_nwritten();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_ByteBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_ByteBuffer),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
pub type L_BBUFFER = L_ByteBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashmap {
    pub nitems: l_int32,
    pub ntogo: l_int32,
    pub maxocc: l_int32,
    pub hashtab: *mut *mut L_Hashitem,
    pub tabsize: l_int32,
}
#[test]
fn bindgen_test_layout_L_Hashmap() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashmap>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashmap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashmap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashmap))
    );
    fn test_field_nitems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashmap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nitems) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashmap),
                "::",
                stringify!(nitems)
            )
        );
    }
    test_field_nitems();
    fn test_field_ntogo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashmap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ntogo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashmap),
                "::",
                stringify!(ntogo)
            )
        );
    }
    test_field_ntogo();
    fn test_field_maxocc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashmap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxocc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashmap),
                "::",
                stringify!(maxocc)
            )
        );
    }
    test_field_maxocc();
    fn test_field_hashtab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashmap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hashtab) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashmap),
                "::",
                stringify!(hashtab)
            )
        );
    }
    test_field_hashtab();
    fn test_field_tabsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashmap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tabsize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashmap),
                "::",
                stringify!(tabsize)
            )
        );
    }
    test_field_tabsize();
}
pub type L_HASHMAP = L_Hashmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashitem {
    pub key: l_uint64,
    pub val: l_uint64,
    pub count: l_int32,
    pub next: *mut L_Hashitem,
}
#[test]
fn bindgen_test_layout_L_Hashitem() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashitem>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashitem))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashitem>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashitem))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashitem>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashitem),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashitem>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashitem),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashitem>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashitem),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Hashitem>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Hashitem),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub type L_HASHITEM = L_Hashitem;
pub const L_UNDEFINED: _bindgen_ty_7 = 0;
pub const L_HMAP_CHECK: _bindgen_ty_7 = 1;
pub const L_HMAP_CREATE: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Heap {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub direction: l_int32,
}
#[test]
fn bindgen_test_layout_L_Heap() {
    assert_eq!(
        ::std::mem::size_of::<L_Heap>(),
        24usize,
        concat!("Size of: ", stringify!(L_Heap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Heap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Heap))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Heap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Heap),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Heap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(L_Heap), "::", stringify!(n))
        );
    }
    test_field_n();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Heap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Heap),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_direction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Heap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Heap),
                "::",
                stringify!(direction)
            )
        );
    }
    test_field_direction();
}
pub type L_HEAP = L_Heap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoubleLinkedList {
    pub prev: *mut DoubleLinkedList,
    pub next: *mut DoubleLinkedList,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DoubleLinkedList() {
    assert_eq!(
        ::std::mem::size_of::<DoubleLinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        ::std::mem::align_of::<DoubleLinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(DoubleLinkedList))
    );
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DoubleLinkedList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(DoubleLinkedList),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DoubleLinkedList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(DoubleLinkedList),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DoubleLinkedList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(DoubleLinkedList),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub type DLLIST = DoubleLinkedList;
extern "C" {
    pub static MaxInitPtraSize: l_uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptra {
    pub nalloc: l_int32,
    pub imax: l_int32,
    pub nactual: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_L_Ptra() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptra>(),
        24usize,
        concat!("Size of: ", stringify!(L_Ptra))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptra>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptra))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptra>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptra),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_imax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptra>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imax) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptra),
                "::",
                stringify!(imax)
            )
        );
    }
    test_field_imax();
    fn test_field_nactual() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptra>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nactual) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptra),
                "::",
                stringify!(nactual)
            )
        );
    }
    test_field_nactual();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptra>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptra),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
pub type L_PTRA = L_Ptra;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptraa {
    pub nalloc: l_int32,
    pub ptra: *mut *mut L_Ptra,
}
#[test]
fn bindgen_test_layout_L_Ptraa() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptraa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Ptraa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptraa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptraa))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptraa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptraa),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_ptra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Ptraa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptra) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Ptraa),
                "::",
                stringify!(ptra)
            )
        );
    }
    test_field_ptra();
}
pub type L_PTRAA = L_Ptraa;
pub const L_NO_COMPACTION: _bindgen_ty_8 = 1;
pub const L_COMPACTION: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const L_AUTO_DOWNSHIFT: _bindgen_ty_9 = 0;
pub const L_MIN_DOWNSHIFT: _bindgen_ty_9 = 1;
pub const L_FULL_DOWNSHIFT: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const L_HANDLE_ONLY: _bindgen_ty_10 = 0;
pub const L_REMOVE: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Queue {
    pub nalloc: l_int32,
    pub nhead: l_int32,
    pub nelem: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub stack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Queue() {
    assert_eq!(
        ::std::mem::size_of::<L_Queue>(),
        32usize,
        concat!("Size of: ", stringify!(L_Queue))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Queue>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Queue))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Queue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Queue),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_nhead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Queue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nhead) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Queue),
                "::",
                stringify!(nhead)
            )
        );
    }
    test_field_nhead();
    fn test_field_nelem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Queue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nelem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Queue),
                "::",
                stringify!(nelem)
            )
        );
    }
    test_field_nelem();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Queue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Queue),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Queue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Queue),
                "::",
                stringify!(stack)
            )
        );
    }
    test_field_stack();
}
pub type L_QUEUE = L_Queue;
pub const L_INT_TYPE: _bindgen_ty_11 = 1;
pub const L_UINT_TYPE: _bindgen_ty_11 = 2;
pub const L_FLOAT_TYPE: _bindgen_ty_11 = 3;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rb_Type {
    pub itype: l_int64,
    pub utype: l_uint64,
    pub ftype: l_float64,
    pub ptype: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Rb_Type() {
    assert_eq!(
        ::std::mem::size_of::<Rb_Type>(),
        8usize,
        concat!("Size of: ", stringify!(Rb_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Rb_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(Rb_Type))
    );
    fn test_field_itype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Rb_Type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).itype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Rb_Type),
                "::",
                stringify!(itype)
            )
        );
    }
    test_field_itype();
    fn test_field_utype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Rb_Type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Rb_Type),
                "::",
                stringify!(utype)
            )
        );
    }
    test_field_utype();
    fn test_field_ftype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Rb_Type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Rb_Type),
                "::",
                stringify!(ftype)
            )
        );
    }
    test_field_ftype();
    fn test_field_ptype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Rb_Type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Rb_Type),
                "::",
                stringify!(ptype)
            )
        );
    }
    test_field_ptype();
}
pub type RB_TYPE = Rb_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rbtree {
    pub root: *mut L_Rbtree_Node,
    pub keytype: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree>(),
        16usize,
        concat!("Size of: ", stringify!(L_Rbtree))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree))
    );
    fn test_field_root() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree),
                "::",
                stringify!(root)
            )
        );
    }
    test_field_root();
    fn test_field_keytype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree),
                "::",
                stringify!(keytype)
            )
        );
    }
    test_field_keytype();
}
pub type L_RBTREE = L_Rbtree;
pub type L_AMAP = L_Rbtree;
pub type L_ASET = L_Rbtree;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct L_Rbtree_Node {
    pub key: Rb_Type,
    pub value: Rb_Type,
    pub left: *mut L_Rbtree_Node,
    pub right: *mut L_Rbtree_Node,
    pub parent: *mut L_Rbtree_Node,
    pub color: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree_Node() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree_Node>(),
        48usize,
        concat!("Size of: ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree_Node))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rbtree_Node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rbtree_Node),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
pub type L_RBTREE_NODE = L_Rbtree_Node;
pub type L_AMAP_NODE = L_Rbtree_Node;
pub type L_ASET_NODE = L_Rbtree_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Stack {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub auxstack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Stack() {
    assert_eq!(
        ::std::mem::size_of::<L_Stack>(),
        24usize,
        concat!("Size of: ", stringify!(L_Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Stack))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Stack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Stack),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Stack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Stack),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Stack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Stack),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_auxstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Stack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auxstack) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Stack),
                "::",
                stringify!(auxstack)
            )
        );
    }
    test_field_auxstack();
}
pub type L_STACK = L_Stack;
pub const SPLIT_ON_LEADING_WHITE: _bindgen_ty_12 = 1;
pub const SPLIT_ON_BLANK_LINE: _bindgen_ty_12 = 2;
pub const SPLIT_ON_BOTH: _bindgen_ty_12 = 3;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bmf {
    pub pixa: *mut Pixa,
    pub size: l_int32,
    pub directory: *mut ::std::os::raw::c_char,
    pub baseline1: l_int32,
    pub baseline2: l_int32,
    pub baseline3: l_int32,
    pub lineheight: l_int32,
    pub kernwidth: l_int32,
    pub spacewidth: l_int32,
    pub vertlinesep: l_int32,
    pub fonttab: *mut l_int32,
    pub baselinetab: *mut l_int32,
    pub widthtab: *mut l_int32,
}
#[test]
fn bindgen_test_layout_L_Bmf() {
    assert_eq!(
        ::std::mem::size_of::<L_Bmf>(),
        80usize,
        concat!("Size of: ", stringify!(L_Bmf))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bmf>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bmf))
    );
    fn test_field_pixa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(pixa)
            )
        );
    }
    test_field_pixa();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_directory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(directory)
            )
        );
    }
    test_field_directory();
    fn test_field_baseline1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseline1) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(baseline1)
            )
        );
    }
    test_field_baseline1();
    fn test_field_baseline2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseline2) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(baseline2)
            )
        );
    }
    test_field_baseline2();
    fn test_field_baseline3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseline3) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(baseline3)
            )
        );
    }
    test_field_baseline3();
    fn test_field_lineheight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineheight) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(lineheight)
            )
        );
    }
    test_field_lineheight();
    fn test_field_kernwidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernwidth) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(kernwidth)
            )
        );
    }
    test_field_kernwidth();
    fn test_field_spacewidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spacewidth) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(spacewidth)
            )
        );
    }
    test_field_spacewidth();
    fn test_field_vertlinesep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertlinesep) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(vertlinesep)
            )
        );
    }
    test_field_vertlinesep();
    fn test_field_fonttab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fonttab) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(fonttab)
            )
        );
    }
    test_field_fonttab();
    fn test_field_baselinetab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baselinetab) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(baselinetab)
            )
        );
    }
    test_field_baselinetab();
    fn test_field_widthtab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Bmf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).widthtab) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Bmf),
                "::",
                stringify!(widthtab)
            )
        );
    }
    test_field_widthtab();
}
pub type L_BMF = L_Bmf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBord {
    _unused: [u8; 0],
}
pub type CCBORD = CCBord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBorda {
    _unused: [u8; 0],
}
pub type CCBORDA = CCBorda;
pub const CCB_LOCAL_COORDS: _bindgen_ty_13 = 1;
pub const CCB_GLOBAL_COORDS: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const CCB_SAVE_ALL_PTS: _bindgen_ty_14 = 1;
pub const CCB_SAVE_TURNING_PTS: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Colorfill {
    pub pixs: *mut Pix,
    pub pixst: *mut Pix,
    pub nx: l_int32,
    pub ny: l_int32,
    pub tw: l_int32,
    pub th: l_int32,
    pub minarea: l_int32,
    pub boxas: *mut Boxa,
    pub pixas: *mut Pixa,
    pub pixam: *mut Pixa,
    pub naa: *mut Numaa,
    pub dnaa: *mut L_Dnaa,
    pub pixadb: *mut Pixa,
}
#[test]
fn bindgen_test_layout_L_Colorfill() {
    assert_eq!(
        ::std::mem::size_of::<L_Colorfill>(),
        88usize,
        concat!("Size of: ", stringify!(L_Colorfill))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Colorfill>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Colorfill))
    );
    fn test_field_pixs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(pixs)
            )
        );
    }
    test_field_pixs();
    fn test_field_pixst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixst) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(pixst)
            )
        );
    }
    test_field_pixst();
    fn test_field_nx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nx) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(nx)
            )
        );
    }
    test_field_nx();
    fn test_field_ny() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ny) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(ny)
            )
        );
    }
    test_field_ny();
    fn test_field_tw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tw) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(tw)
            )
        );
    }
    test_field_tw();
    fn test_field_th() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(th)
            )
        );
    }
    test_field_th();
    fn test_field_minarea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minarea) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(minarea)
            )
        );
    }
    test_field_minarea();
    fn test_field_boxas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boxas) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(boxas)
            )
        );
    }
    test_field_boxas();
    fn test_field_pixas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixas) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(pixas)
            )
        );
    }
    test_field_pixas();
    fn test_field_pixam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixam) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(pixam)
            )
        );
    }
    test_field_pixam();
    fn test_field_naa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naa) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(naa)
            )
        );
    }
    test_field_naa();
    fn test_field_dnaa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dnaa) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(dnaa)
            )
        );
    }
    test_field_dnaa();
    fn test_field_pixadb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Colorfill>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixadb) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Colorfill),
                "::",
                stringify!(pixadb)
            )
        );
    }
    test_field_pixadb();
}
pub type L_COLORFILL = L_Colorfill;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarpa {
    pub nalloc: l_int32,
    pub maxpage: l_int32,
    pub dewarp: *mut *mut L_Dewarp,
    pub dewarpcache: *mut *mut L_Dewarp,
    pub namodels: *mut Numa,
    pub napages: *mut Numa,
    pub redfactor: l_int32,
    pub sampling: l_int32,
    pub minlines: l_int32,
    pub maxdist: l_int32,
    pub max_linecurv: l_int32,
    pub min_diff_linecurv: l_int32,
    pub max_diff_linecurv: l_int32,
    pub max_edgeslope: l_int32,
    pub max_edgecurv: l_int32,
    pub max_diff_edgecurv: l_int32,
    pub useboth: l_int32,
    pub check_columns: l_int32,
    pub modelsready: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarpa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarpa>(),
        96usize,
        concat!("Size of: ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarpa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarpa))
    );
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_maxpage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxpage) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(maxpage)
            )
        );
    }
    test_field_maxpage();
    fn test_field_dewarp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dewarp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(dewarp)
            )
        );
    }
    test_field_dewarp();
    fn test_field_dewarpcache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dewarpcache) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(dewarpcache)
            )
        );
    }
    test_field_dewarpcache();
    fn test_field_namodels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namodels) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(namodels)
            )
        );
    }
    test_field_namodels();
    fn test_field_napages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).napages) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(napages)
            )
        );
    }
    test_field_napages();
    fn test_field_redfactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redfactor) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(redfactor)
            )
        );
    }
    test_field_redfactor();
    fn test_field_sampling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(sampling)
            )
        );
    }
    test_field_sampling();
    fn test_field_minlines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minlines) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(minlines)
            )
        );
    }
    test_field_minlines();
    fn test_field_maxdist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxdist) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(maxdist)
            )
        );
    }
    test_field_maxdist();
    fn test_field_max_linecurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_linecurv) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(max_linecurv)
            )
        );
    }
    test_field_max_linecurv();
    fn test_field_min_diff_linecurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_diff_linecurv) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(min_diff_linecurv)
            )
        );
    }
    test_field_min_diff_linecurv();
    fn test_field_max_diff_linecurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_diff_linecurv) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(max_diff_linecurv)
            )
        );
    }
    test_field_max_diff_linecurv();
    fn test_field_max_edgeslope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_edgeslope) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(max_edgeslope)
            )
        );
    }
    test_field_max_edgeslope();
    fn test_field_max_edgecurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_edgecurv) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(max_edgecurv)
            )
        );
    }
    test_field_max_edgecurv();
    fn test_field_max_diff_edgecurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_diff_edgecurv) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(max_diff_edgecurv)
            )
        );
    }
    test_field_max_diff_edgecurv();
    fn test_field_useboth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).useboth) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(useboth)
            )
        );
    }
    test_field_useboth();
    fn test_field_check_columns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).check_columns) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(check_columns)
            )
        );
    }
    test_field_check_columns();
    fn test_field_modelsready() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarpa>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modelsready) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarpa),
                "::",
                stringify!(modelsready)
            )
        );
    }
    test_field_modelsready();
}
pub type L_DEWARPA = L_Dewarpa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarp {
    pub dewa: *mut L_Dewarpa,
    pub pixs: *mut Pix,
    pub sampvdispar: *mut FPix,
    pub samphdispar: *mut FPix,
    pub sampydispar: *mut FPix,
    pub fullvdispar: *mut FPix,
    pub fullhdispar: *mut FPix,
    pub fullydispar: *mut FPix,
    pub namidys: *mut Numa,
    pub nacurves: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub pageno: l_int32,
    pub sampling: l_int32,
    pub redfactor: l_int32,
    pub minlines: l_int32,
    pub nlines: l_int32,
    pub mincurv: l_int32,
    pub maxcurv: l_int32,
    pub leftslope: l_int32,
    pub rightslope: l_int32,
    pub leftcurv: l_int32,
    pub rightcurv: l_int32,
    pub nx: l_int32,
    pub ny: l_int32,
    pub hasref: l_int32,
    pub refpage: l_int32,
    pub vsuccess: l_int32,
    pub hsuccess: l_int32,
    pub ysuccess: l_int32,
    pub vvalid: l_int32,
    pub hvalid: l_int32,
    pub skip_horiz: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarp() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarp>(),
        176usize,
        concat!("Size of: ", stringify!(L_Dewarp))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarp>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarp))
    );
    fn test_field_dewa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dewa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(dewa)
            )
        );
    }
    test_field_dewa();
    fn test_field_pixs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(pixs)
            )
        );
    }
    test_field_pixs();
    fn test_field_sampvdispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampvdispar) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(sampvdispar)
            )
        );
    }
    test_field_sampvdispar();
    fn test_field_samphdispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samphdispar) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(samphdispar)
            )
        );
    }
    test_field_samphdispar();
    fn test_field_sampydispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampydispar) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(sampydispar)
            )
        );
    }
    test_field_sampydispar();
    fn test_field_fullvdispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullvdispar) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(fullvdispar)
            )
        );
    }
    test_field_fullvdispar();
    fn test_field_fullhdispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullhdispar) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(fullhdispar)
            )
        );
    }
    test_field_fullhdispar();
    fn test_field_fullydispar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullydispar) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(fullydispar)
            )
        );
    }
    test_field_fullydispar();
    fn test_field_namidys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namidys) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(namidys)
            )
        );
    }
    test_field_namidys();
    fn test_field_nacurves() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nacurves) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(nacurves)
            )
        );
    }
    test_field_nacurves();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(h)
            )
        );
    }
    test_field_h();
    fn test_field_pageno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageno) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(pageno)
            )
        );
    }
    test_field_pageno();
    fn test_field_sampling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(sampling)
            )
        );
    }
    test_field_sampling();
    fn test_field_redfactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redfactor) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(redfactor)
            )
        );
    }
    test_field_redfactor();
    fn test_field_minlines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minlines) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(minlines)
            )
        );
    }
    test_field_minlines();
    fn test_field_nlines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlines) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(nlines)
            )
        );
    }
    test_field_nlines();
    fn test_field_mincurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mincurv) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(mincurv)
            )
        );
    }
    test_field_mincurv();
    fn test_field_maxcurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxcurv) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(maxcurv)
            )
        );
    }
    test_field_maxcurv();
    fn test_field_leftslope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).leftslope) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(leftslope)
            )
        );
    }
    test_field_leftslope();
    fn test_field_rightslope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rightslope) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(rightslope)
            )
        );
    }
    test_field_rightslope();
    fn test_field_leftcurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).leftcurv) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(leftcurv)
            )
        );
    }
    test_field_leftcurv();
    fn test_field_rightcurv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rightcurv) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(rightcurv)
            )
        );
    }
    test_field_rightcurv();
    fn test_field_nx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nx) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(nx)
            )
        );
    }
    test_field_nx();
    fn test_field_ny() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ny) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(ny)
            )
        );
    }
    test_field_ny();
    fn test_field_hasref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasref) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(hasref)
            )
        );
    }
    test_field_hasref();
    fn test_field_refpage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refpage) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(refpage)
            )
        );
    }
    test_field_refpage();
    fn test_field_vsuccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vsuccess) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(vsuccess)
            )
        );
    }
    test_field_vsuccess();
    fn test_field_hsuccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hsuccess) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(hsuccess)
            )
        );
    }
    test_field_hsuccess();
    fn test_field_ysuccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ysuccess) as usize - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(ysuccess)
            )
        );
    }
    test_field_ysuccess();
    fn test_field_vvalid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vvalid) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(vvalid)
            )
        );
    }
    test_field_vvalid();
    fn test_field_hvalid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hvalid) as usize - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(hvalid)
            )
        );
    }
    test_field_hvalid();
    fn test_field_skip_horiz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).skip_horiz) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(skip_horiz)
            )
        );
    }
    test_field_skip_horiz();
    fn test_field_debug() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Dewarp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Dewarp),
                "::",
                stringify!(debug)
            )
        );
    }
    test_field_debug();
}
pub type L_DEWARP = L_Dewarp;
pub const GPLOT_STYLE_GPLOT_LINES: GPLOT_STYLE = 0;
pub const GPLOT_STYLE_GPLOT_POINTS: GPLOT_STYLE = 1;
pub const GPLOT_STYLE_GPLOT_IMPULSES: GPLOT_STYLE = 2;
pub const GPLOT_STYLE_GPLOT_LINESPOINTS: GPLOT_STYLE = 3;
pub const GPLOT_STYLE_GPLOT_DOTS: GPLOT_STYLE = 4;
pub type GPLOT_STYLE = ::std::os::raw::c_uint;
pub const GPLOT_OUTPUT_GPLOT_NONE: GPLOT_OUTPUT = 0;
pub const GPLOT_OUTPUT_GPLOT_PNG: GPLOT_OUTPUT = 1;
pub const GPLOT_OUTPUT_GPLOT_PS: GPLOT_OUTPUT = 2;
pub const GPLOT_OUTPUT_GPLOT_EPS: GPLOT_OUTPUT = 3;
pub const GPLOT_OUTPUT_GPLOT_LATEX: GPLOT_OUTPUT = 4;
pub const GPLOT_OUTPUT_GPLOT_PNM: GPLOT_OUTPUT = 5;
pub type GPLOT_OUTPUT = ::std::os::raw::c_uint;
pub const GPLOT_SCALING_GPLOT_LINEAR_SCALE: GPLOT_SCALING = 0;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X: GPLOT_SCALING = 1;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_Y: GPLOT_SCALING = 2;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X_Y: GPLOT_SCALING = 3;
pub type GPLOT_SCALING = ::std::os::raw::c_uint;
extern "C" {
    pub static mut gplotstylenames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut gplotfileoutputs: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPlot {
    pub rootname: *mut ::std::os::raw::c_char,
    pub cmdname: *mut ::std::os::raw::c_char,
    pub cmddata: *mut Sarray,
    pub datanames: *mut Sarray,
    pub plotdata: *mut Sarray,
    pub plotlabels: *mut Sarray,
    pub plotstyles: *mut Numa,
    pub nplots: l_int32,
    pub outname: *mut ::std::os::raw::c_char,
    pub outformat: l_int32,
    pub scaling: l_int32,
    pub title: *mut ::std::os::raw::c_char,
    pub xlabel: *mut ::std::os::raw::c_char,
    pub ylabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GPlot() {
    assert_eq!(
        ::std::mem::size_of::<GPlot>(),
        104usize,
        concat!("Size of: ", stringify!(GPlot))
    );
    assert_eq!(
        ::std::mem::align_of::<GPlot>(),
        8usize,
        concat!("Alignment of ", stringify!(GPlot))
    );
    fn test_field_rootname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rootname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(rootname)
            )
        );
    }
    test_field_rootname();
    fn test_field_cmdname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(cmdname)
            )
        );
    }
    test_field_cmdname();
    fn test_field_cmddata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmddata) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(cmddata)
            )
        );
    }
    test_field_cmddata();
    fn test_field_datanames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datanames) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(datanames)
            )
        );
    }
    test_field_datanames();
    fn test_field_plotdata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).plotdata) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(plotdata)
            )
        );
    }
    test_field_plotdata();
    fn test_field_plotlabels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).plotlabels) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(plotlabels)
            )
        );
    }
    test_field_plotlabels();
    fn test_field_plotstyles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).plotstyles) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(plotstyles)
            )
        );
    }
    test_field_plotstyles();
    fn test_field_nplots() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nplots) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(nplots)
            )
        );
    }
    test_field_nplots();
    fn test_field_outname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outname) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(outname)
            )
        );
    }
    test_field_outname();
    fn test_field_outformat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outformat) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(outformat)
            )
        );
    }
    test_field_outformat();
    fn test_field_scaling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(scaling)
            )
        );
    }
    test_field_scaling();
    fn test_field_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(title)
            )
        );
    }
    test_field_title();
    fn test_field_xlabel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xlabel) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(xlabel)
            )
        );
    }
    test_field_xlabel();
    fn test_field_ylabel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GPlot>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ylabel) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(GPlot),
                "::",
                stringify!(ylabel)
            )
        );
    }
    test_field_ylabel();
}
pub type GPLOT = GPlot;
pub const IFF_UNKNOWN: _bindgen_ty_15 = 0;
pub const IFF_BMP: _bindgen_ty_15 = 1;
pub const IFF_JFIF_JPEG: _bindgen_ty_15 = 2;
pub const IFF_PNG: _bindgen_ty_15 = 3;
pub const IFF_TIFF: _bindgen_ty_15 = 4;
pub const IFF_TIFF_PACKBITS: _bindgen_ty_15 = 5;
pub const IFF_TIFF_RLE: _bindgen_ty_15 = 6;
pub const IFF_TIFF_G3: _bindgen_ty_15 = 7;
pub const IFF_TIFF_G4: _bindgen_ty_15 = 8;
pub const IFF_TIFF_LZW: _bindgen_ty_15 = 9;
pub const IFF_TIFF_ZIP: _bindgen_ty_15 = 10;
pub const IFF_PNM: _bindgen_ty_15 = 11;
pub const IFF_PS: _bindgen_ty_15 = 12;
pub const IFF_GIF: _bindgen_ty_15 = 13;
pub const IFF_JP2: _bindgen_ty_15 = 14;
pub const IFF_WEBP: _bindgen_ty_15 = 15;
pub const IFF_LPDF: _bindgen_ty_15 = 16;
pub const IFF_TIFF_JPEG: _bindgen_ty_15 = 17;
pub const IFF_DEFAULT: _bindgen_ty_15 = 18;
pub const IFF_SPIX: _bindgen_ty_15 = 19;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const BMP_ID: _bindgen_ty_16 = 19778;
pub const TIFF_BIGEND_ID: _bindgen_ty_16 = 19789;
pub const TIFF_LITTLEEND_ID: _bindgen_ty_16 = 18761;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const L_JPEG_READ_LUMINANCE: _bindgen_ty_17 = 1;
pub const L_JPEG_CONTINUE_WITH_BAD_DATA: _bindgen_ty_17 = 2;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const L_J2K_CODEC: _bindgen_ty_18 = 1;
pub const L_JP2_CODEC: _bindgen_ty_18 = 2;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const L_DEFAULT_ENCODE: _bindgen_ty_19 = 0;
pub const L_JPEG_ENCODE: _bindgen_ty_19 = 1;
pub const L_G4_ENCODE: _bindgen_ty_19 = 2;
pub const L_FLATE_ENCODE: _bindgen_ty_19 = 3;
pub const L_JP2K_ENCODE: _bindgen_ty_19 = 4;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Compressed_Data {
    pub type_: l_int32,
    pub datacomp: *mut l_uint8,
    pub nbytescomp: size_t,
    pub data85: *mut ::std::os::raw::c_char,
    pub nbytes85: size_t,
    pub cmapdata85: *mut ::std::os::raw::c_char,
    pub cmapdatahex: *mut ::std::os::raw::c_char,
    pub ncolors: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub bps: l_int32,
    pub spp: l_int32,
    pub minisblack: l_int32,
    pub predictor: l_int32,
    pub nbytes: size_t,
    pub res: l_int32,
}
#[test]
fn bindgen_test_layout_L_Compressed_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Compressed_Data>(),
        104usize,
        concat!("Size of: ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Compressed_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Compressed_Data))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_datacomp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datacomp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(datacomp)
            )
        );
    }
    test_field_datacomp();
    fn test_field_nbytescomp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytescomp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(nbytescomp)
            )
        );
    }
    test_field_nbytescomp();
    fn test_field_data85() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data85) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(data85)
            )
        );
    }
    test_field_data85();
    fn test_field_nbytes85() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes85) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(nbytes85)
            )
        );
    }
    test_field_nbytes85();
    fn test_field_cmapdata85() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmapdata85) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(cmapdata85)
            )
        );
    }
    test_field_cmapdata85();
    fn test_field_cmapdatahex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmapdatahex) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(cmapdatahex)
            )
        );
    }
    test_field_cmapdatahex();
    fn test_field_ncolors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncolors) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(ncolors)
            )
        );
    }
    test_field_ncolors();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(h)
            )
        );
    }
    test_field_h();
    fn test_field_bps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bps) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(bps)
            )
        );
    }
    test_field_bps();
    fn test_field_spp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spp) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(spp)
            )
        );
    }
    test_field_spp();
    fn test_field_minisblack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minisblack) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(minisblack)
            )
        );
    }
    test_field_minisblack();
    fn test_field_predictor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).predictor) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(predictor)
            )
        );
    }
    test_field_predictor();
    fn test_field_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(nbytes)
            )
        );
    }
    test_field_nbytes();
    fn test_field_res() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Compressed_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Compressed_Data),
                "::",
                stringify!(res)
            )
        );
    }
    test_field_res();
}
pub type L_COMP_DATA = L_Compressed_Data;
pub const L_FIRST_IMAGE: _bindgen_ty_20 = 1;
pub const L_NEXT_IMAGE: _bindgen_ty_20 = 2;
pub const L_LAST_IMAGE: _bindgen_ty_20 = 3;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Pdf_Data {
    pub title: *mut ::std::os::raw::c_char,
    pub n: l_int32,
    pub ncmap: l_int32,
    pub cida: *mut L_Ptra,
    pub id: *mut ::std::os::raw::c_char,
    pub obj1: *mut ::std::os::raw::c_char,
    pub obj2: *mut ::std::os::raw::c_char,
    pub obj3: *mut ::std::os::raw::c_char,
    pub obj4: *mut ::std::os::raw::c_char,
    pub obj5: *mut ::std::os::raw::c_char,
    pub poststream: *mut ::std::os::raw::c_char,
    pub trailer: *mut ::std::os::raw::c_char,
    pub xy: *mut Pta,
    pub wh: *mut Pta,
    pub mediabox: *mut Box,
    pub saprex: *mut Sarray,
    pub sacmap: *mut Sarray,
    pub objsize: *mut L_Dna,
    pub objloc: *mut L_Dna,
    pub xrefloc: l_int32,
}
#[test]
fn bindgen_test_layout_L_Pdf_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Pdf_Data>(),
        152usize,
        concat!("Size of: ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Pdf_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Pdf_Data))
    );
    fn test_field_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(title)
            )
        );
    }
    test_field_title();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_ncmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncmap) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(ncmap)
            )
        );
    }
    test_field_ncmap();
    fn test_field_cida() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cida) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(cida)
            )
        );
    }
    test_field_cida();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_obj1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj1) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(obj1)
            )
        );
    }
    test_field_obj1();
    fn test_field_obj2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(obj2)
            )
        );
    }
    test_field_obj2();
    fn test_field_obj3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj3) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(obj3)
            )
        );
    }
    test_field_obj3();
    fn test_field_obj4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj4) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(obj4)
            )
        );
    }
    test_field_obj4();
    fn test_field_obj5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj5) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(obj5)
            )
        );
    }
    test_field_obj5();
    fn test_field_poststream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poststream) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(poststream)
            )
        );
    }
    test_field_poststream();
    fn test_field_trailer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trailer) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(trailer)
            )
        );
    }
    test_field_trailer();
    fn test_field_xy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xy) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(xy)
            )
        );
    }
    test_field_xy();
    fn test_field_wh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wh) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(wh)
            )
        );
    }
    test_field_wh();
    fn test_field_mediabox() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mediabox) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(mediabox)
            )
        );
    }
    test_field_mediabox();
    fn test_field_saprex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).saprex) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(saprex)
            )
        );
    }
    test_field_saprex();
    fn test_field_sacmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sacmap) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(sacmap)
            )
        );
    }
    test_field_sacmap();
    fn test_field_objsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objsize) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(objsize)
            )
        );
    }
    test_field_objsize();
    fn test_field_objloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objloc) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(objloc)
            )
        );
    }
    test_field_objloc();
    fn test_field_xrefloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Pdf_Data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xrefloc) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Pdf_Data),
                "::",
                stringify!(xrefloc)
            )
        );
    }
    test_field_xrefloc();
}
pub type L_PDF_DATA = L_Pdf_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbClasser {
    pub safiles: *mut Sarray,
    pub method: l_int32,
    pub components: l_int32,
    pub maxwidth: l_int32,
    pub maxheight: l_int32,
    pub npages: l_int32,
    pub baseindex: l_int32,
    pub nacomps: *mut Numa,
    pub sizehaus: l_int32,
    pub rankhaus: l_float32,
    pub thresh: l_float32,
    pub weightfactor: l_float32,
    pub naarea: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub keep_pixaa: l_int32,
    pub pixaa: *mut Pixaa,
    pub pixat: *mut Pixa,
    pub pixatd: *mut Pixa,
    pub dahash: *mut L_DnaHash,
    pub nafgt: *mut Numa,
    pub ptac: *mut Pta,
    pub ptact: *mut Pta,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
    pub ptall: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbClasser() {
    assert_eq!(
        ::std::mem::size_of::<JbClasser>(),
        168usize,
        concat!("Size of: ", stringify!(JbClasser))
    );
    assert_eq!(
        ::std::mem::align_of::<JbClasser>(),
        8usize,
        concat!("Alignment of ", stringify!(JbClasser))
    );
    fn test_field_safiles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).safiles) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(safiles)
            )
        );
    }
    test_field_safiles();
    fn test_field_method() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(method)
            )
        );
    }
    test_field_method();
    fn test_field_components() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(components)
            )
        );
    }
    test_field_components();
    fn test_field_maxwidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxwidth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(maxwidth)
            )
        );
    }
    test_field_maxwidth();
    fn test_field_maxheight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxheight) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(maxheight)
            )
        );
    }
    test_field_maxheight();
    fn test_field_npages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npages) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(npages)
            )
        );
    }
    test_field_npages();
    fn test_field_baseindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseindex) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(baseindex)
            )
        );
    }
    test_field_baseindex();
    fn test_field_nacomps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nacomps) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(nacomps)
            )
        );
    }
    test_field_nacomps();
    fn test_field_sizehaus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizehaus) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(sizehaus)
            )
        );
    }
    test_field_sizehaus();
    fn test_field_rankhaus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rankhaus) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(rankhaus)
            )
        );
    }
    test_field_rankhaus();
    fn test_field_thresh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thresh) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(thresh)
            )
        );
    }
    test_field_thresh();
    fn test_field_weightfactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).weightfactor) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(weightfactor)
            )
        );
    }
    test_field_weightfactor();
    fn test_field_naarea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naarea) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(naarea)
            )
        );
    }
    test_field_naarea();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(h)
            )
        );
    }
    test_field_h();
    fn test_field_nclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nclass) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(nclass)
            )
        );
    }
    test_field_nclass();
    fn test_field_keep_pixaa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keep_pixaa) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(keep_pixaa)
            )
        );
    }
    test_field_keep_pixaa();
    fn test_field_pixaa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixaa) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(pixaa)
            )
        );
    }
    test_field_pixaa();
    fn test_field_pixat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixat) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(pixat)
            )
        );
    }
    test_field_pixat();
    fn test_field_pixatd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixatd) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(pixatd)
            )
        );
    }
    test_field_pixatd();
    fn test_field_dahash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dahash) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(dahash)
            )
        );
    }
    test_field_dahash();
    fn test_field_nafgt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nafgt) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(nafgt)
            )
        );
    }
    test_field_nafgt();
    fn test_field_ptac() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptac) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(ptac)
            )
        );
    }
    test_field_ptac();
    fn test_field_ptact() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptact) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(ptact)
            )
        );
    }
    test_field_ptact();
    fn test_field_naclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naclass) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(naclass)
            )
        );
    }
    test_field_naclass();
    fn test_field_napage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).napage) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(napage)
            )
        );
    }
    test_field_napage();
    fn test_field_ptaul() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptaul) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(ptaul)
            )
        );
    }
    test_field_ptaul();
    fn test_field_ptall() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbClasser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptall) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(JbClasser),
                "::",
                stringify!(ptall)
            )
        );
    }
    test_field_ptall();
}
pub type JBCLASSER = JbClasser;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbData {
    pub pix: *mut Pix,
    pub npages: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub latticew: l_int32,
    pub latticeh: l_int32,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbData() {
    assert_eq!(
        ::std::mem::size_of::<JbData>(),
        56usize,
        concat!("Size of: ", stringify!(JbData))
    );
    assert_eq!(
        ::std::mem::align_of::<JbData>(),
        8usize,
        concat!("Alignment of ", stringify!(JbData))
    );
    fn test_field_pix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(pix)
            )
        );
    }
    test_field_pix();
    fn test_field_npages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npages) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(npages)
            )
        );
    }
    test_field_npages();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(JbData), "::", stringify!(w))
        );
    }
    test_field_w();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(JbData), "::", stringify!(h))
        );
    }
    test_field_h();
    fn test_field_nclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nclass) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(nclass)
            )
        );
    }
    test_field_nclass();
    fn test_field_latticew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).latticew) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(latticew)
            )
        );
    }
    test_field_latticew();
    fn test_field_latticeh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).latticeh) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(latticeh)
            )
        );
    }
    test_field_latticeh();
    fn test_field_naclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naclass) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(naclass)
            )
        );
    }
    test_field_naclass();
    fn test_field_napage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).napage) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(napage)
            )
        );
    }
    test_field_napage();
    fn test_field_ptaul() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<JbData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptaul) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JbData),
                "::",
                stringify!(ptaul)
            )
        );
    }
    test_field_ptaul();
}
pub type JBDATA = JbData;
pub const JB_RANKHAUS: _bindgen_ty_21 = 0;
pub const JB_CORRELATION: _bindgen_ty_21 = 1;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const JB_CONN_COMPS: _bindgen_ty_22 = 0;
pub const JB_CHARACTERS: _bindgen_ty_22 = 1;
pub const JB_WORDS: _bindgen_ty_22 = 2;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_int32,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sel() {
    assert_eq!(
        ::std::mem::size_of::<Sel>(),
        32usize,
        concat!("Size of: ", stringify!(Sel))
    );
    assert_eq!(
        ::std::mem::align_of::<Sel>(),
        8usize,
        concat!("Alignment of ", stringify!(Sel))
    );
    fn test_field_sy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sy))
        );
    }
    test_field_sy();
    fn test_field_sx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sx))
        );
    }
    test_field_sx();
    fn test_field_cy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cy))
        );
    }
    test_field_cy();
    fn test_field_cx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cx))
        );
    }
    test_field_cx();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(data))
        );
    }
    test_field_data();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(Sel), "::", stringify!(name))
        );
    }
    test_field_name();
}
pub type SEL = Sel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sela {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub sel: *mut *mut Sel,
}
#[test]
fn bindgen_test_layout_Sela() {
    assert_eq!(
        ::std::mem::size_of::<Sela>(),
        16usize,
        concat!("Size of: ", stringify!(Sela))
    );
    assert_eq!(
        ::std::mem::align_of::<Sela>(),
        8usize,
        concat!("Alignment of ", stringify!(Sela))
    );
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sela>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Sela), "::", stringify!(n))
        );
    }
    test_field_n();
    fn test_field_nalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sela>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Sela),
                "::",
                stringify!(nalloc)
            )
        );
    }
    test_field_nalloc();
    fn test_field_sel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Sela>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sel) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(Sela), "::", stringify!(sel))
        );
    }
    test_field_sel();
}
pub type SELA = Sela;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Kernel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_float32,
}
#[test]
fn bindgen_test_layout_L_Kernel() {
    assert_eq!(
        ::std::mem::size_of::<L_Kernel>(),
        24usize,
        concat!("Size of: ", stringify!(L_Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Kernel))
    );
    fn test_field_sy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Kernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Kernel),
                "::",
                stringify!(sy)
            )
        );
    }
    test_field_sy();
    fn test_field_sx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Kernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Kernel),
                "::",
                stringify!(sx)
            )
        );
    }
    test_field_sx();
    fn test_field_cy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Kernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Kernel),
                "::",
                stringify!(cy)
            )
        );
    }
    test_field_cy();
    fn test_field_cx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Kernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Kernel),
                "::",
                stringify!(cx)
            )
        );
    }
    test_field_cx();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Kernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Kernel),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub type L_KERNEL = L_Kernel;
pub const SYMMETRIC_MORPH_BC: _bindgen_ty_23 = 0;
pub const ASYMMETRIC_MORPH_BC: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const SEL_DONT_CARE: _bindgen_ty_24 = 0;
pub const SEL_HIT: _bindgen_ty_24 = 1;
pub const SEL_MISS: _bindgen_ty_24 = 2;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const L_RUN_OFF: _bindgen_ty_25 = 0;
pub const L_RUN_ON: _bindgen_ty_25 = 1;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const L_HORIZ: _bindgen_ty_26 = 1;
pub const L_VERT: _bindgen_ty_26 = 2;
pub const L_BOTH_DIRECTIONS: _bindgen_ty_26 = 3;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const L_MORPH_DILATE: _bindgen_ty_27 = 1;
pub const L_MORPH_ERODE: _bindgen_ty_27 = 2;
pub const L_MORPH_OPEN: _bindgen_ty_27 = 3;
pub const L_MORPH_CLOSE: _bindgen_ty_27 = 4;
pub const L_MORPH_HMT: _bindgen_ty_27 = 5;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const L_LINEAR_SCALE: _bindgen_ty_28 = 1;
pub const L_LOG_SCALE: _bindgen_ty_28 = 2;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const L_TOPHAT_WHITE: _bindgen_ty_29 = 0;
pub const L_TOPHAT_BLACK: _bindgen_ty_29 = 1;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const L_ARITH_ADD: _bindgen_ty_30 = 1;
pub const L_ARITH_SUBTRACT: _bindgen_ty_30 = 2;
pub const L_ARITH_MULTIPLY: _bindgen_ty_30 = 3;
pub const L_ARITH_DIVIDE: _bindgen_ty_30 = 4;
pub const L_UNION: _bindgen_ty_30 = 5;
pub const L_INTERSECTION: _bindgen_ty_30 = 6;
pub const L_SUBTRACTION: _bindgen_ty_30 = 7;
pub const L_EXCLUSIVE_OR: _bindgen_ty_30 = 8;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const L_CHOOSE_MIN: _bindgen_ty_31 = 1;
pub const L_CHOOSE_MAX: _bindgen_ty_31 = 2;
pub const L_CHOOSE_MAXDIFF: _bindgen_ty_31 = 3;
pub const L_CHOOSE_MIN_BOOST: _bindgen_ty_31 = 4;
pub const L_CHOOSE_MAX_BOOST: _bindgen_ty_31 = 5;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const L_BOUNDARY_BG: _bindgen_ty_32 = 1;
pub const L_BOUNDARY_FG: _bindgen_ty_32 = 2;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const L_COMPARE_XOR: _bindgen_ty_33 = 1;
pub const L_COMPARE_SUBTRACT: _bindgen_ty_33 = 2;
pub const L_COMPARE_ABS_DIFF: _bindgen_ty_33 = 3;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const ADDED_BORDER: l_int32 = 32;
pub type PIX = Pix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixColormap {
    _unused: [u8; 0],
}
pub type PIXCMAP = PixColormap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBA_Quad {
    _unused: [u8; 0],
}
pub type RGBA_QUAD = RGBA_Quad;
pub type PIXA = Pixa;
pub type PIXAA = Pixaa;
pub type BOX = Box;
pub type BOXA = Boxa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxaa {
    _unused: [u8; 0],
}
pub type BOXAA = Boxaa;
pub type PTA = Pta;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ptaa {
    _unused: [u8; 0],
}
pub type PTAA = Ptaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixacc {
    _unused: [u8; 0],
}
pub type PIXACC = Pixacc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixTiling {
    _unused: [u8; 0],
}
pub type PIXTILING = PixTiling;
pub type FPIX = FPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPixa {
    _unused: [u8; 0],
}
pub type FPIXA = FPixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPix {
    _unused: [u8; 0],
}
pub type DPIX = DPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixComp {
    _unused: [u8; 0],
}
pub type PIXC = PixComp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixaComp {
    _unused: [u8; 0],
}
pub type PIXAC = PixaComp;
pub const COLOR_RED: _bindgen_ty_34 = 0;
pub const COLOR_GREEN: _bindgen_ty_34 = 1;
pub const COLOR_BLUE: _bindgen_ty_34 = 2;
pub const L_ALPHA_CHANNEL: _bindgen_ty_34 = 3;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const L_RED_SHIFT: l_int32 = 24;
pub const L_GREEN_SHIFT: l_int32 = 16;
pub const L_BLUE_SHIFT: l_int32 = 8;
pub const L_ALPHA_SHIFT: l_int32 = 0;
pub const L_DRAW_RED: _bindgen_ty_35 = 0;
pub const L_DRAW_GREEN: _bindgen_ty_35 = 1;
pub const L_DRAW_BLUE: _bindgen_ty_35 = 2;
pub const L_DRAW_SPECIFIED: _bindgen_ty_35 = 3;
pub const L_DRAW_RGB: _bindgen_ty_35 = 4;
pub const L_DRAW_RANDOM: _bindgen_ty_35 = 5;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const L_RED_WEIGHT: l_float32 = 0.30000001192092896;
pub const L_GREEN_WEIGHT: l_float32 = 0.5;
pub const L_BLUE_WEIGHT: l_float32 = 0.20000000298023224;
pub const REMOVE_CMAP_TO_BINARY: _bindgen_ty_36 = 0;
pub const REMOVE_CMAP_TO_GRAYSCALE: _bindgen_ty_36 = 1;
pub const REMOVE_CMAP_TO_FULL_COLOR: _bindgen_ty_36 = 2;
pub const REMOVE_CMAP_WITH_ALPHA: _bindgen_ty_36 = 3;
pub const REMOVE_CMAP_BASED_ON_SRC: _bindgen_ty_36 = 4;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const L_NOCOPY: _bindgen_ty_37 = 0;
pub const L_INSERT: _bindgen_ty_37 = 0;
pub const L_COPY: _bindgen_ty_37 = 1;
pub const L_CLONE: _bindgen_ty_37 = 2;
pub const L_COPY_CLONE: _bindgen_ty_37 = 3;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const L_SHELL_SORT: _bindgen_ty_38 = 1;
pub const L_BIN_SORT: _bindgen_ty_38 = 2;
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const L_SORT_INCREASING: _bindgen_ty_39 = 1;
pub const L_SORT_DECREASING: _bindgen_ty_39 = 2;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const L_SORT_BY_X: _bindgen_ty_40 = 1;
pub const L_SORT_BY_Y: _bindgen_ty_40 = 2;
pub const L_SORT_BY_RIGHT: _bindgen_ty_40 = 3;
pub const L_SORT_BY_BOT: _bindgen_ty_40 = 4;
pub const L_SORT_BY_WIDTH: _bindgen_ty_40 = 5;
pub const L_SORT_BY_HEIGHT: _bindgen_ty_40 = 6;
pub const L_SORT_BY_MIN_DIMENSION: _bindgen_ty_40 = 7;
pub const L_SORT_BY_MAX_DIMENSION: _bindgen_ty_40 = 8;
pub const L_SORT_BY_PERIMETER: _bindgen_ty_40 = 9;
pub const L_SORT_BY_AREA: _bindgen_ty_40 = 10;
pub const L_SORT_BY_ASPECT_RATIO: _bindgen_ty_40 = 11;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const L_BLEND_WITH_INVERSE: _bindgen_ty_41 = 1;
pub const L_BLEND_TO_WHITE: _bindgen_ty_41 = 2;
pub const L_BLEND_TO_BLACK: _bindgen_ty_41 = 3;
pub const L_BLEND_GRAY: _bindgen_ty_41 = 4;
pub const L_BLEND_GRAY_WITH_INVERSE: _bindgen_ty_41 = 5;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const L_PAINT_LIGHT: _bindgen_ty_42 = 1;
pub const L_PAINT_DARK: _bindgen_ty_42 = 2;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const L_SET_PIXELS: _bindgen_ty_43 = 1;
pub const L_CLEAR_PIXELS: _bindgen_ty_43 = 2;
pub const L_FLIP_PIXELS: _bindgen_ty_43 = 3;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const L_SELECT_IF_LT: _bindgen_ty_44 = 1;
pub const L_SELECT_IF_GT: _bindgen_ty_44 = 2;
pub const L_SELECT_IF_LTE: _bindgen_ty_44 = 3;
pub const L_SELECT_IF_GTE: _bindgen_ty_44 = 4;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const L_SELECT_BY_WIDTH: _bindgen_ty_45 = 1;
pub const L_SELECT_BY_HEIGHT: _bindgen_ty_45 = 2;
pub const L_SELECT_BY_MAX_DIMENSION: _bindgen_ty_45 = 3;
pub const L_SELECT_BY_AREA: _bindgen_ty_45 = 4;
pub const L_SELECT_BY_PERIMETER: _bindgen_ty_45 = 5;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const L_SELECT_WIDTH: _bindgen_ty_46 = 1;
pub const L_SELECT_HEIGHT: _bindgen_ty_46 = 2;
pub const L_SELECT_XVAL: _bindgen_ty_46 = 3;
pub const L_SELECT_YVAL: _bindgen_ty_46 = 4;
pub const L_SELECT_IF_EITHER: _bindgen_ty_46 = 5;
pub const L_SELECT_IF_BOTH: _bindgen_ty_46 = 6;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const L_CHECK_WIDTH: _bindgen_ty_47 = 1;
pub const L_CHECK_HEIGHT: _bindgen_ty_47 = 2;
pub const L_CHECK_BOTH: _bindgen_ty_47 = 3;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const L_SELECT_RED: _bindgen_ty_48 = 1;
pub const L_SELECT_GREEN: _bindgen_ty_48 = 2;
pub const L_SELECT_BLUE: _bindgen_ty_48 = 3;
pub const L_SELECT_MIN: _bindgen_ty_48 = 4;
pub const L_SELECT_MAX: _bindgen_ty_48 = 5;
pub const L_SELECT_AVERAGE: _bindgen_ty_48 = 6;
pub const L_SELECT_HUE: _bindgen_ty_48 = 7;
pub const L_SELECT_SATURATION: _bindgen_ty_48 = 8;
pub const L_SELECT_WEIGHTED: _bindgen_ty_48 = 9;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const L_INTERMED_DIFF: _bindgen_ty_49 = 1;
pub const L_AVE_MAX_DIFF_2: _bindgen_ty_49 = 2;
pub const L_MAX_DIFF: _bindgen_ty_49 = 3;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const L_LS_BYTE: _bindgen_ty_50 = 1;
pub const L_MS_BYTE: _bindgen_ty_50 = 2;
pub const L_AUTO_BYTE: _bindgen_ty_50 = 3;
pub const L_CLIP_TO_FF: _bindgen_ty_50 = 4;
pub const L_LS_TWO_BYTES: _bindgen_ty_50 = 5;
pub const L_MS_TWO_BYTES: _bindgen_ty_50 = 6;
pub const L_CLIP_TO_FFFF: _bindgen_ty_50 = 7;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const L_ROTATE_AREA_MAP: _bindgen_ty_51 = 1;
pub const L_ROTATE_SHEAR: _bindgen_ty_51 = 2;
pub const L_ROTATE_SAMPLING: _bindgen_ty_51 = 3;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const L_BRING_IN_WHITE: _bindgen_ty_52 = 1;
pub const L_BRING_IN_BLACK: _bindgen_ty_52 = 2;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const L_SHEAR_ABOUT_CORNER: _bindgen_ty_53 = 1;
pub const L_SHEAR_ABOUT_CENTER: _bindgen_ty_53 = 2;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const L_TR_SC_RO: _bindgen_ty_54 = 1;
pub const L_SC_RO_TR: _bindgen_ty_54 = 2;
pub const L_RO_TR_SC: _bindgen_ty_54 = 3;
pub const L_TR_RO_SC: _bindgen_ty_54 = 4;
pub const L_RO_SC_TR: _bindgen_ty_54 = 5;
pub const L_SC_TR_RO: _bindgen_ty_54 = 6;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const L_FILL_WHITE: _bindgen_ty_55 = 1;
pub const L_FILL_BLACK: _bindgen_ty_55 = 2;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub const L_SET_WHITE: _bindgen_ty_56 = 1;
pub const L_SET_BLACK: _bindgen_ty_56 = 2;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const L_GET_WHITE_VAL: _bindgen_ty_57 = 1;
pub const L_GET_BLACK_VAL: _bindgen_ty_57 = 2;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const L_WHITE_IS_MAX: _bindgen_ty_58 = 1;
pub const L_BLACK_IS_MAX: _bindgen_ty_58 = 2;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const DEFAULT_CLIP_LOWER_1: _bindgen_ty_59 = 10;
pub const DEFAULT_CLIP_UPPER_1: _bindgen_ty_59 = 10;
pub const DEFAULT_CLIP_LOWER_2: _bindgen_ty_59 = 5;
pub const DEFAULT_CLIP_UPPER_2: _bindgen_ty_59 = 5;
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const L_MANHATTAN_DISTANCE: _bindgen_ty_60 = 1;
pub const L_EUCLIDEAN_DISTANCE: _bindgen_ty_60 = 2;
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
pub const L_NEGATIVE: _bindgen_ty_61 = 1;
pub const L_NON_NEGATIVE: _bindgen_ty_61 = 2;
pub const L_POSITIVE: _bindgen_ty_61 = 3;
pub const L_NON_POSITIVE: _bindgen_ty_61 = 4;
pub const L_ZERO: _bindgen_ty_61 = 5;
pub const L_ALL: _bindgen_ty_61 = 6;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const L_MEAN_ABSVAL: _bindgen_ty_62 = 1;
pub const L_MEDIAN_VAL: _bindgen_ty_62 = 2;
pub const L_MODE_VAL: _bindgen_ty_62 = 3;
pub const L_MODE_COUNT: _bindgen_ty_62 = 4;
pub const L_ROOT_MEAN_SQUARE: _bindgen_ty_62 = 5;
pub const L_STANDARD_DEVIATION: _bindgen_ty_62 = 6;
pub const L_VARIANCE: _bindgen_ty_62 = 7;
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub const L_CHOOSE_CONSECUTIVE: _bindgen_ty_63 = 1;
pub const L_CHOOSE_SKIP_BY: _bindgen_ty_63 = 2;
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const L_TEXT_ORIENT_UNKNOWN: _bindgen_ty_64 = 0;
pub const L_TEXT_ORIENT_UP: _bindgen_ty_64 = 1;
pub const L_TEXT_ORIENT_LEFT: _bindgen_ty_64 = 2;
pub const L_TEXT_ORIENT_DOWN: _bindgen_ty_64 = 3;
pub const L_TEXT_ORIENT_RIGHT: _bindgen_ty_64 = 4;
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_EDGES: _bindgen_ty_65 = 0;
pub const L_VERTICAL_EDGES: _bindgen_ty_65 = 1;
pub const L_ALL_EDGES: _bindgen_ty_65 = 2;
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_LINE: _bindgen_ty_66 = 0;
pub const L_POS_SLOPE_LINE: _bindgen_ty_66 = 1;
pub const L_VERTICAL_LINE: _bindgen_ty_66 = 2;
pub const L_NEG_SLOPE_LINE: _bindgen_ty_66 = 3;
pub const L_OBLIQUE_LINE: _bindgen_ty_66 = 4;
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
pub const L_PORTRAIT_MODE: _bindgen_ty_67 = 0;
pub const L_LANDSCAPE_MODE: _bindgen_ty_67 = 1;
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const L_FROM_LEFT: _bindgen_ty_68 = 0;
pub const L_FROM_RIGHT: _bindgen_ty_68 = 1;
pub const L_FROM_TOP: _bindgen_ty_68 = 2;
pub const L_FROM_BOT: _bindgen_ty_68 = 3;
pub const L_SCAN_NEGATIVE: _bindgen_ty_68 = 4;
pub const L_SCAN_POSITIVE: _bindgen_ty_68 = 5;
pub const L_SCAN_BOTH: _bindgen_ty_68 = 6;
pub const L_SCAN_HORIZONTAL: _bindgen_ty_68 = 7;
pub const L_SCAN_VERTICAL: _bindgen_ty_68 = 8;
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const L_ADJUST_SKIP: _bindgen_ty_69 = 0;
pub const L_ADJUST_LEFT: _bindgen_ty_69 = 1;
pub const L_ADJUST_RIGHT: _bindgen_ty_69 = 2;
pub const L_ADJUST_LEFT_AND_RIGHT: _bindgen_ty_69 = 3;
pub const L_ADJUST_TOP: _bindgen_ty_69 = 4;
pub const L_ADJUST_BOT: _bindgen_ty_69 = 5;
pub const L_ADJUST_TOP_AND_BOT: _bindgen_ty_69 = 6;
pub const L_ADJUST_CHOOSE_MIN: _bindgen_ty_69 = 7;
pub const L_ADJUST_CHOOSE_MAX: _bindgen_ty_69 = 8;
pub const L_SET_LEFT: _bindgen_ty_69 = 9;
pub const L_SET_RIGHT: _bindgen_ty_69 = 10;
pub const L_SET_TOP: _bindgen_ty_69 = 11;
pub const L_SET_BOT: _bindgen_ty_69 = 12;
pub const L_GET_LEFT: _bindgen_ty_69 = 13;
pub const L_GET_RIGHT: _bindgen_ty_69 = 14;
pub const L_GET_TOP: _bindgen_ty_69 = 15;
pub const L_GET_BOT: _bindgen_ty_69 = 16;
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const L_USE_MINSIZE: _bindgen_ty_70 = 1;
pub const L_USE_MAXSIZE: _bindgen_ty_70 = 2;
pub const L_SUB_ON_LOC_DIFF: _bindgen_ty_70 = 3;
pub const L_SUB_ON_SIZE_DIFF: _bindgen_ty_70 = 4;
pub const L_USE_CAPPED_MIN: _bindgen_ty_70 = 5;
pub const L_USE_CAPPED_MAX: _bindgen_ty_70 = 6;
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const L_COMBINE: _bindgen_ty_71 = 1;
pub const L_REMOVE_SMALL: _bindgen_ty_71 = 2;
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
pub const L_GEOMETRIC_UNION: _bindgen_ty_72 = 1;
pub const L_GEOMETRIC_INTERSECTION: _bindgen_ty_72 = 2;
pub const L_LARGEST_AREA: _bindgen_ty_72 = 3;
pub const L_SMALLEST_AREA: _bindgen_ty_72 = 4;
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
pub const L_USE_ALL_BOXES: _bindgen_ty_73 = 1;
pub const L_USE_SAME_PARITY_BOXES: _bindgen_ty_73 = 2;
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const L_UPPER_LEFT: _bindgen_ty_74 = 1;
pub const L_UPPER_RIGHT: _bindgen_ty_74 = 2;
pub const L_LOWER_LEFT: _bindgen_ty_74 = 3;
pub const L_LOWER_RIGHT: _bindgen_ty_74 = 4;
pub const L_BOX_CENTER: _bindgen_ty_74 = 5;
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
pub const L_WARP_TO_LEFT: _bindgen_ty_75 = 1;
pub const L_WARP_TO_RIGHT: _bindgen_ty_75 = 2;
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const L_LINEAR_WARP: _bindgen_ty_76 = 1;
pub const L_QUADRATIC_WARP: _bindgen_ty_76 = 2;
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
pub const L_INTERPOLATED: _bindgen_ty_77 = 1;
pub const L_SAMPLED: _bindgen_ty_77 = 2;
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
pub const L_THIN_FG: _bindgen_ty_78 = 1;
pub const L_THIN_BG: _bindgen_ty_78 = 2;
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_RUNS: _bindgen_ty_79 = 0;
pub const L_VERTICAL_RUNS: _bindgen_ty_79 = 1;
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const L_SOBEL_EDGE: _bindgen_ty_80 = 1;
pub const L_TWO_SIDED_EDGE: _bindgen_ty_80 = 2;
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const L_SUBPIXEL_ORDER_RGB: _bindgen_ty_81 = 1;
pub const L_SUBPIXEL_ORDER_BGR: _bindgen_ty_81 = 2;
pub const L_SUBPIXEL_ORDER_VRGB: _bindgen_ty_81 = 3;
pub const L_SUBPIXEL_ORDER_VBGR: _bindgen_ty_81 = 4;
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
pub const L_HS_HISTO: _bindgen_ty_82 = 1;
pub const L_HV_HISTO: _bindgen_ty_82 = 2;
pub const L_SV_HISTO: _bindgen_ty_82 = 3;
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
pub const L_INCLUDE_REGION: _bindgen_ty_83 = 1;
pub const L_EXCLUDE_REGION: _bindgen_ty_83 = 2;
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
pub const L_ADD_ABOVE: _bindgen_ty_84 = 1;
pub const L_ADD_BELOW: _bindgen_ty_84 = 2;
pub const L_ADD_LEFT: _bindgen_ty_84 = 3;
pub const L_ADD_RIGHT: _bindgen_ty_84 = 4;
pub const L_ADD_AT_TOP: _bindgen_ty_84 = 5;
pub const L_ADD_AT_BOT: _bindgen_ty_84 = 6;
pub const L_ADD_AT_LEFT: _bindgen_ty_84 = 7;
pub const L_ADD_AT_RIGHT: _bindgen_ty_84 = 8;
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
pub const L_PLOT_AT_TOP: _bindgen_ty_85 = 1;
pub const L_PLOT_AT_MID_HORIZ: _bindgen_ty_85 = 2;
pub const L_PLOT_AT_BOT: _bindgen_ty_85 = 3;
pub const L_PLOT_AT_LEFT: _bindgen_ty_85 = 4;
pub const L_PLOT_AT_MID_VERT: _bindgen_ty_85 = 5;
pub const L_PLOT_AT_RIGHT: _bindgen_ty_85 = 6;
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
pub const L_USE_INNER: _bindgen_ty_86 = 1;
pub const L_USE_OUTER: _bindgen_ty_86 = 2;
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
pub const L_DISPLAY_WITH_XZGV: _bindgen_ty_87 = 1;
pub const L_DISPLAY_WITH_XLI: _bindgen_ty_87 = 2;
pub const L_DISPLAY_WITH_XV: _bindgen_ty_87 = 3;
pub const L_DISPLAY_WITH_IV: _bindgen_ty_87 = 4;
pub const L_DISPLAY_WITH_OPEN: _bindgen_ty_87 = 5;
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
pub const L_NO_CHROMA_SAMPLING_JPEG: _bindgen_ty_88 = 1;
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
pub const L_CLIP_TO_ZERO: _bindgen_ty_89 = 1;
pub const L_TAKE_ABSVAL: _bindgen_ty_89 = 2;
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
pub const L_LESS_THAN_ZERO: _bindgen_ty_90 = 1;
pub const L_EQUAL_TO_ZERO: _bindgen_ty_90 = 2;
pub const L_GREATER_THAN_ZERO: _bindgen_ty_90 = 3;
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
pub const L_ADD_TRAIL_SLASH: _bindgen_ty_91 = 1;
pub const L_REMOVE_TRAIL_SLASH: _bindgen_ty_91 = 2;
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
pub type alloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
pub type dealloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Recog {
    pub scalew: l_int32,
    pub scaleh: l_int32,
    pub linew: l_int32,
    pub templ_use: l_int32,
    pub maxarraysize: l_int32,
    pub setsize: l_int32,
    pub threshold: l_int32,
    pub maxyshift: l_int32,
    pub charset_type: l_int32,
    pub charset_size: l_int32,
    pub min_nopad: l_int32,
    pub num_samples: l_int32,
    pub minwidth_u: l_int32,
    pub maxwidth_u: l_int32,
    pub minheight_u: l_int32,
    pub maxheight_u: l_int32,
    pub minwidth: l_int32,
    pub maxwidth: l_int32,
    pub ave_done: l_int32,
    pub train_done: l_int32,
    pub max_wh_ratio: l_float32,
    pub max_ht_ratio: l_float32,
    pub min_splitw: l_int32,
    pub max_splith: l_int32,
    pub sa_text: *mut Sarray,
    pub dna_tochar: *mut L_Dna,
    pub centtab: *mut l_int32,
    pub sumtab: *mut l_int32,
    pub pixaa_u: *mut Pixaa,
    pub ptaa_u: *mut Ptaa,
    pub naasum_u: *mut Numaa,
    pub pixaa: *mut Pixaa,
    pub ptaa: *mut Ptaa,
    pub naasum: *mut Numaa,
    pub pixa_u: *mut Pixa,
    pub pta_u: *mut Pta,
    pub nasum_u: *mut Numa,
    pub pixa: *mut Pixa,
    pub pta: *mut Pta,
    pub nasum: *mut Numa,
    pub pixa_tr: *mut Pixa,
    pub pixadb_ave: *mut Pixa,
    pub pixa_id: *mut Pixa,
    pub pixdb_ave: *mut Pix,
    pub pixdb_range: *mut Pix,
    pub pixadb_boot: *mut Pixa,
    pub pixadb_split: *mut Pixa,
    pub bmf: *mut L_Bmf,
    pub bmf_size: l_int32,
    pub did: *mut L_Rdid,
    pub rch: *mut L_Rch,
    pub rcha: *mut L_Rcha,
}
#[test]
fn bindgen_test_layout_L_Recog() {
    assert_eq!(
        ::std::mem::size_of::<L_Recog>(),
        320usize,
        concat!("Size of: ", stringify!(L_Recog))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Recog>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Recog))
    );
    fn test_field_scalew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scalew) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(scalew)
            )
        );
    }
    test_field_scalew();
    fn test_field_scaleh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scaleh) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(scaleh)
            )
        );
    }
    test_field_scaleh();
    fn test_field_linew() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linew) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(linew)
            )
        );
    }
    test_field_linew();
    fn test_field_templ_use() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).templ_use) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(templ_use)
            )
        );
    }
    test_field_templ_use();
    fn test_field_maxarraysize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxarraysize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(maxarraysize)
            )
        );
    }
    test_field_maxarraysize();
    fn test_field_setsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setsize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(setsize)
            )
        );
    }
    test_field_setsize();
    fn test_field_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(threshold)
            )
        );
    }
    test_field_threshold();
    fn test_field_maxyshift() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxyshift) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(maxyshift)
            )
        );
    }
    test_field_maxyshift();
    fn test_field_charset_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).charset_type) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(charset_type)
            )
        );
    }
    test_field_charset_type();
    fn test_field_charset_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).charset_size) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(charset_size)
            )
        );
    }
    test_field_charset_size();
    fn test_field_min_nopad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_nopad) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(min_nopad)
            )
        );
    }
    test_field_min_nopad();
    fn test_field_num_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_samples) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(num_samples)
            )
        );
    }
    test_field_num_samples();
    fn test_field_minwidth_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minwidth_u) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(minwidth_u)
            )
        );
    }
    test_field_minwidth_u();
    fn test_field_maxwidth_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxwidth_u) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(maxwidth_u)
            )
        );
    }
    test_field_maxwidth_u();
    fn test_field_minheight_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minheight_u) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(minheight_u)
            )
        );
    }
    test_field_minheight_u();
    fn test_field_maxheight_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxheight_u) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(maxheight_u)
            )
        );
    }
    test_field_maxheight_u();
    fn test_field_minwidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minwidth) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(minwidth)
            )
        );
    }
    test_field_minwidth();
    fn test_field_maxwidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxwidth) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(maxwidth)
            )
        );
    }
    test_field_maxwidth();
    fn test_field_ave_done() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ave_done) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(ave_done)
            )
        );
    }
    test_field_ave_done();
    fn test_field_train_done() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).train_done) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(train_done)
            )
        );
    }
    test_field_train_done();
    fn test_field_max_wh_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_wh_ratio) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(max_wh_ratio)
            )
        );
    }
    test_field_max_wh_ratio();
    fn test_field_max_ht_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_ht_ratio) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(max_ht_ratio)
            )
        );
    }
    test_field_max_ht_ratio();
    fn test_field_min_splitw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_splitw) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(min_splitw)
            )
        );
    }
    test_field_min_splitw();
    fn test_field_max_splith() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_splith) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(max_splith)
            )
        );
    }
    test_field_max_splith();
    fn test_field_sa_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_text) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(sa_text)
            )
        );
    }
    test_field_sa_text();
    fn test_field_dna_tochar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dna_tochar) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(dna_tochar)
            )
        );
    }
    test_field_dna_tochar();
    fn test_field_centtab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).centtab) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(centtab)
            )
        );
    }
    test_field_centtab();
    fn test_field_sumtab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sumtab) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(sumtab)
            )
        );
    }
    test_field_sumtab();
    fn test_field_pixaa_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixaa_u) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixaa_u)
            )
        );
    }
    test_field_pixaa_u();
    fn test_field_ptaa_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptaa_u) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(ptaa_u)
            )
        );
    }
    test_field_ptaa_u();
    fn test_field_naasum_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naasum_u) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(naasum_u)
            )
        );
    }
    test_field_naasum_u();
    fn test_field_pixaa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixaa) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixaa)
            )
        );
    }
    test_field_pixaa();
    fn test_field_ptaa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptaa) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(ptaa)
            )
        );
    }
    test_field_ptaa();
    fn test_field_naasum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naasum) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(naasum)
            )
        );
    }
    test_field_naasum();
    fn test_field_pixa_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixa_u) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixa_u)
            )
        );
    }
    test_field_pixa_u();
    fn test_field_pta_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pta_u) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pta_u)
            )
        );
    }
    test_field_pta_u();
    fn test_field_nasum_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasum_u) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(nasum_u)
            )
        );
    }
    test_field_nasum_u();
    fn test_field_pixa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixa) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixa)
            )
        );
    }
    test_field_pixa();
    fn test_field_pta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pta) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pta)
            )
        );
    }
    test_field_pta();
    fn test_field_nasum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasum) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(nasum)
            )
        );
    }
    test_field_nasum();
    fn test_field_pixa_tr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixa_tr) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixa_tr)
            )
        );
    }
    test_field_pixa_tr();
    fn test_field_pixadb_ave() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixadb_ave) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixadb_ave)
            )
        );
    }
    test_field_pixadb_ave();
    fn test_field_pixa_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixa_id) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixa_id)
            )
        );
    }
    test_field_pixa_id();
    fn test_field_pixdb_ave() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixdb_ave) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixdb_ave)
            )
        );
    }
    test_field_pixdb_ave();
    fn test_field_pixdb_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixdb_range) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixdb_range)
            )
        );
    }
    test_field_pixdb_range();
    fn test_field_pixadb_boot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixadb_boot) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixadb_boot)
            )
        );
    }
    test_field_pixadb_boot();
    fn test_field_pixadb_split() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixadb_split) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(pixadb_split)
            )
        );
    }
    test_field_pixadb_split();
    fn test_field_bmf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bmf) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(bmf)
            )
        );
    }
    test_field_bmf();
    fn test_field_bmf_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bmf_size) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(bmf_size)
            )
        );
    }
    test_field_bmf_size();
    fn test_field_did() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).did) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(did)
            )
        );
    }
    test_field_did();
    fn test_field_rch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rch) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(rch)
            )
        );
    }
    test_field_rch();
    fn test_field_rcha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Recog>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rcha) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Recog),
                "::",
                stringify!(rcha)
            )
        );
    }
    test_field_rcha();
}
pub type L_RECOG = L_Recog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rch {
    pub index: l_int32,
    pub score: l_float32,
    pub text: *mut ::std::os::raw::c_char,
    pub sample: l_int32,
    pub xloc: l_int32,
    pub yloc: l_int32,
    pub width: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rch() {
    assert_eq!(
        ::std::mem::size_of::<L_Rch>(),
        32usize,
        concat!("Size of: ", stringify!(L_Rch))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rch>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rch))
    );
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_score() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).score) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(score)
            )
        );
    }
    test_field_score();
    fn test_field_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(text)
            )
        );
    }
    test_field_text();
    fn test_field_sample() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(sample)
            )
        );
    }
    test_field_sample();
    fn test_field_xloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xloc) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(xloc)
            )
        );
    }
    test_field_xloc();
    fn test_field_yloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).yloc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(yloc)
            )
        );
    }
    test_field_yloc();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rch>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rch),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
}
pub type L_RCH = L_Rch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rcha {
    pub naindex: *mut Numa,
    pub nascore: *mut Numa,
    pub satext: *mut Sarray,
    pub nasample: *mut Numa,
    pub naxloc: *mut Numa,
    pub nayloc: *mut Numa,
    pub nawidth: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rcha() {
    assert_eq!(
        ::std::mem::size_of::<L_Rcha>(),
        56usize,
        concat!("Size of: ", stringify!(L_Rcha))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rcha>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rcha))
    );
    fn test_field_naindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naindex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(naindex)
            )
        );
    }
    test_field_naindex();
    fn test_field_nascore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nascore) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(nascore)
            )
        );
    }
    test_field_nascore();
    fn test_field_satext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).satext) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(satext)
            )
        );
    }
    test_field_satext();
    fn test_field_nasample() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasample) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(nasample)
            )
        );
    }
    test_field_nasample();
    fn test_field_naxloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naxloc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(naxloc)
            )
        );
    }
    test_field_naxloc();
    fn test_field_nayloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nayloc) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(nayloc)
            )
        );
    }
    test_field_nayloc();
    fn test_field_nawidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rcha>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nawidth) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rcha),
                "::",
                stringify!(nawidth)
            )
        );
    }
    test_field_nawidth();
}
pub type L_RCHA = L_Rcha;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rdid {
    pub pixs: *mut Pix,
    pub counta: *mut *mut l_int32,
    pub delya: *mut *mut l_int32,
    pub narray: l_int32,
    pub size: l_int32,
    pub setwidth: *mut l_int32,
    pub nasum: *mut Numa,
    pub namoment: *mut Numa,
    pub fullarrays: l_int32,
    pub beta: *mut l_float32,
    pub gamma: *mut l_float32,
    pub trellisscore: *mut l_float32,
    pub trellistempl: *mut l_int32,
    pub natempl: *mut Numa,
    pub naxloc: *mut Numa,
    pub nadely: *mut Numa,
    pub nawidth: *mut Numa,
    pub boxa: *mut Boxa,
    pub nascore: *mut Numa,
    pub natempl_r: *mut Numa,
    pub nasample_r: *mut Numa,
    pub naxloc_r: *mut Numa,
    pub nadely_r: *mut Numa,
    pub nawidth_r: *mut Numa,
    pub nascore_r: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rdid() {
    assert_eq!(
        ::std::mem::size_of::<L_Rdid>(),
        192usize,
        concat!("Size of: ", stringify!(L_Rdid))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rdid>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rdid))
    );
    fn test_field_pixs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(pixs)
            )
        );
    }
    test_field_pixs();
    fn test_field_counta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).counta) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(counta)
            )
        );
    }
    test_field_counta();
    fn test_field_delya() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delya) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(delya)
            )
        );
    }
    test_field_delya();
    fn test_field_narray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).narray) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(narray)
            )
        );
    }
    test_field_narray();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_setwidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setwidth) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(setwidth)
            )
        );
    }
    test_field_setwidth();
    fn test_field_nasum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasum) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nasum)
            )
        );
    }
    test_field_nasum();
    fn test_field_namoment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namoment) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(namoment)
            )
        );
    }
    test_field_namoment();
    fn test_field_fullarrays() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullarrays) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(fullarrays)
            )
        );
    }
    test_field_fullarrays();
    fn test_field_beta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(beta)
            )
        );
    }
    test_field_beta();
    fn test_field_gamma() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(gamma)
            )
        );
    }
    test_field_gamma();
    fn test_field_trellisscore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trellisscore) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(trellisscore)
            )
        );
    }
    test_field_trellisscore();
    fn test_field_trellistempl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trellistempl) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(trellistempl)
            )
        );
    }
    test_field_trellistempl();
    fn test_field_natempl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).natempl) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(natempl)
            )
        );
    }
    test_field_natempl();
    fn test_field_naxloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naxloc) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(naxloc)
            )
        );
    }
    test_field_naxloc();
    fn test_field_nadely() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nadely) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nadely)
            )
        );
    }
    test_field_nadely();
    fn test_field_nawidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nawidth) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nawidth)
            )
        );
    }
    test_field_nawidth();
    fn test_field_boxa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boxa) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(boxa)
            )
        );
    }
    test_field_boxa();
    fn test_field_nascore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nascore) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nascore)
            )
        );
    }
    test_field_nascore();
    fn test_field_natempl_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).natempl_r) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(natempl_r)
            )
        );
    }
    test_field_natempl_r();
    fn test_field_nasample_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasample_r) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nasample_r)
            )
        );
    }
    test_field_nasample_r();
    fn test_field_naxloc_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).naxloc_r) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(naxloc_r)
            )
        );
    }
    test_field_naxloc_r();
    fn test_field_nadely_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nadely_r) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nadely_r)
            )
        );
    }
    test_field_nadely_r();
    fn test_field_nawidth_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nawidth_r) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nawidth_r)
            )
        );
    }
    test_field_nawidth_r();
    fn test_field_nascore_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Rdid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nascore_r) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Rdid),
                "::",
                stringify!(nascore_r)
            )
        );
    }
    test_field_nascore_r();
}
pub type L_RDID = L_Rdid;
pub const L_UNKNOWN: _bindgen_ty_92 = 0;
pub const L_ARABIC_NUMERALS: _bindgen_ty_92 = 1;
pub const L_LC_ROMAN_NUMERALS: _bindgen_ty_92 = 2;
pub const L_UC_ROMAN_NUMERALS: _bindgen_ty_92 = 3;
pub const L_LC_ALPHA: _bindgen_ty_92 = 4;
pub const L_UC_ALPHA: _bindgen_ty_92 = 5;
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
pub const L_USE_ALL_TEMPLATES: _bindgen_ty_93 = 0;
pub const L_USE_AVERAGE_TEMPLATES: _bindgen_ty_93 = 1;
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_RegParams {
    pub fp: *mut FILE,
    pub testname: *mut ::std::os::raw::c_char,
    pub tempfile: *mut ::std::os::raw::c_char,
    pub mode: l_int32,
    pub index: l_int32,
    pub success: l_int32,
    pub display: l_int32,
    pub tstart: L_TIMER,
}
#[test]
fn bindgen_test_layout_L_RegParams() {
    assert_eq!(
        ::std::mem::size_of::<L_RegParams>(),
        48usize,
        concat!("Size of: ", stringify!(L_RegParams))
    );
    assert_eq!(
        ::std::mem::align_of::<L_RegParams>(),
        8usize,
        concat!("Alignment of ", stringify!(L_RegParams))
    );
    fn test_field_fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(fp)
            )
        );
    }
    test_field_fp();
    fn test_field_testname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).testname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(testname)
            )
        );
    }
    test_field_testname();
    fn test_field_tempfile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tempfile) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(tempfile)
            )
        );
    }
    test_field_tempfile();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_success() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(success)
            )
        );
    }
    test_field_success();
    fn test_field_display() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(display)
            )
        );
    }
    test_field_display();
    fn test_field_tstart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_RegParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tstart) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_RegParams),
                "::",
                stringify!(tstart)
            )
        );
    }
    test_field_tstart();
}
pub type L_REGPARAMS = L_RegParams;
pub const L_REG_GENERATE: _bindgen_ty_94 = 0;
pub const L_REG_COMPARE: _bindgen_ty_94 = 1;
pub const L_REG_DISPLAY: _bindgen_ty_94 = 2;
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_StrCode {
    pub fileno: l_int32,
    pub ifunc: l_int32,
    pub function: *mut SARRAY,
    pub data: *mut SARRAY,
    pub descr: *mut SARRAY,
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_L_StrCode() {
    assert_eq!(
        ::std::mem::size_of::<L_StrCode>(),
        40usize,
        concat!("Size of: ", stringify!(L_StrCode))
    );
    assert_eq!(
        ::std::mem::align_of::<L_StrCode>(),
        8usize,
        concat!("Alignment of ", stringify!(L_StrCode))
    );
    fn test_field_fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileno) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(fileno)
            )
        );
    }
    test_field_fileno();
    fn test_field_ifunc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifunc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(ifunc)
            )
        );
    }
    test_field_ifunc();
    fn test_field_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(function)
            )
        );
    }
    test_field_function();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_descr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(descr)
            )
        );
    }
    test_field_descr();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_StrCode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_StrCode),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
}
pub type L_STRCODE = L_StrCode;
pub const L_STR_TYPE: _bindgen_ty_95 = 0;
pub const L_STR_NAME: _bindgen_ty_95 = 1;
pub const L_STR_READER: _bindgen_ty_95 = 2;
pub const L_STR_MEMREADER: _bindgen_ty_95 = 3;
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Sudoku {
    pub num: l_int32,
    pub locs: *mut l_int32,
    pub current: l_int32,
    pub init: *mut l_int32,
    pub state: *mut l_int32,
    pub nguess: l_int32,
    pub finished: l_int32,
    pub failure: l_int32,
}
#[test]
fn bindgen_test_layout_L_Sudoku() {
    assert_eq!(
        ::std::mem::size_of::<L_Sudoku>(),
        56usize,
        concat!("Size of: ", stringify!(L_Sudoku))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Sudoku>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Sudoku))
    );
    fn test_field_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(num)
            )
        );
    }
    test_field_num();
    fn test_field_locs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(locs)
            )
        );
    }
    test_field_locs();
    fn test_field_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(current)
            )
        );
    }
    test_field_current();
    fn test_field_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(init)
            )
        );
    }
    test_field_init();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_nguess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nguess) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(nguess)
            )
        );
    }
    test_field_nguess();
    fn test_field_finished() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finished) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(finished)
            )
        );
    }
    test_field_finished();
    fn test_field_failure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_Sudoku>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).failure) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_Sudoku),
                "::",
                stringify!(failure)
            )
        );
    }
    test_field_failure();
}
pub type L_SUDOKU = L_Sudoku;
pub const L_SUDOKU_INIT: _bindgen_ty_96 = 0;
pub const L_SUDOKU_STATE: _bindgen_ty_96 = 1;
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WShed {
    pub pixs: *mut Pix,
    pub pixm: *mut Pix,
    pub mindepth: l_int32,
    pub pixlab: *mut Pix,
    pub pixt: *mut Pix,
    pub lines8: *mut *mut ::std::os::raw::c_void,
    pub linem1: *mut *mut ::std::os::raw::c_void,
    pub linelab32: *mut *mut ::std::os::raw::c_void,
    pub linet1: *mut *mut ::std::os::raw::c_void,
    pub pixad: *mut Pixa,
    pub ptas: *mut Pta,
    pub nasi: *mut Numa,
    pub nash: *mut Numa,
    pub namh: *mut Numa,
    pub nalevels: *mut Numa,
    pub nseeds: l_int32,
    pub nother: l_int32,
    pub lut: *mut l_int32,
    pub links: *mut *mut Numa,
    pub arraysize: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_WShed() {
    assert_eq!(
        ::std::mem::size_of::<L_WShed>(),
        152usize,
        concat!("Size of: ", stringify!(L_WShed))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WShed>(),
        8usize,
        concat!("Alignment of ", stringify!(L_WShed))
    );
    fn test_field_pixs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(pixs)
            )
        );
    }
    test_field_pixs();
    fn test_field_pixm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixm) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(pixm)
            )
        );
    }
    test_field_pixm();
    fn test_field_mindepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mindepth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(mindepth)
            )
        );
    }
    test_field_mindepth();
    fn test_field_pixlab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixlab) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(pixlab)
            )
        );
    }
    test_field_pixlab();
    fn test_field_pixt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixt) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(pixt)
            )
        );
    }
    test_field_pixt();
    fn test_field_lines8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lines8) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(lines8)
            )
        );
    }
    test_field_lines8();
    fn test_field_linem1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linem1) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(linem1)
            )
        );
    }
    test_field_linem1();
    fn test_field_linelab32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linelab32) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(linelab32)
            )
        );
    }
    test_field_linelab32();
    fn test_field_linet1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linet1) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(linet1)
            )
        );
    }
    test_field_linet1();
    fn test_field_pixad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixad) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(pixad)
            )
        );
    }
    test_field_pixad();
    fn test_field_ptas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptas) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(ptas)
            )
        );
    }
    test_field_ptas();
    fn test_field_nasi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nasi) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(nasi)
            )
        );
    }
    test_field_nasi();
    fn test_field_nash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nash) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(nash)
            )
        );
    }
    test_field_nash();
    fn test_field_namh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namh) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(namh)
            )
        );
    }
    test_field_namh();
    fn test_field_nalevels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nalevels) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(nalevels)
            )
        );
    }
    test_field_nalevels();
    fn test_field_nseeds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nseeds) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(nseeds)
            )
        );
    }
    test_field_nseeds();
    fn test_field_nother() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nother) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(nother)
            )
        );
    }
    test_field_nother();
    fn test_field_lut() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lut) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(lut)
            )
        );
    }
    test_field_lut();
    fn test_field_links() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).links) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(links)
            )
        );
    }
    test_field_links();
    fn test_field_arraysize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arraysize) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(arraysize)
            )
        );
    }
    test_field_arraysize();
    fn test_field_debug() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<L_WShed>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(L_WShed),
                "::",
                stringify!(debug)
            )
        );
    }
    test_field_debug();
}
pub type L_WSHED = L_WShed;
extern "C" {
    pub fn pixCleanBackgroundToWhite(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormSimple(pixs: *mut PIX, pixim: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormGrayArray(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArrays(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormGrayArrayMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArraysMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixm: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFillMapHoles(pix: *mut PIX, nx: l_int32, ny: l_int32, filltype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixExtendByReplication(pixs: *mut PIX, addw: l_int32, addh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSmoothConnectedRegions(pixs: *mut PIX, pixm: *mut PIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetInvBackgroundMap(
        pixs: *mut PIX,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundGrayMap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundRGBMap(
        pixs: *mut PIX,
        pixmr: *mut PIX,
        pixmg: *mut PIX,
        pixmb: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyVariableGrayMap(pixs: *mut PIX, pixg: *mut PIX, target: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        mapval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormNoSatRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        factor: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdSpreadNorm(
        pixs: *mut PIX,
        filtertype: l_int32,
        edgethresh: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
        targetthresh: l_int32,
        ppixth: *mut *mut PIX,
        ppixb: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormFlex(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastNorm(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffine(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getAffineXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineInvertXform(vc: *mut l_float32, pvci: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn affineXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelColor(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        colorval: l_uint32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelGray(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        grayval: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn gaussjordan(a: *mut *mut l_float32, b: *mut l_float32, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAffineSequential(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        bw: l_int32,
        bh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn createMatrix2dTranslate(transx: l_float32, transy: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dScale(scalex: l_float32, scaley: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dRotate(xc: l_float32, yc: l_float32, angle: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn ptaTranslate(ptas: *mut PTA, transx: l_float32, transy: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaScale(ptas: *mut PTA, scalex: l_float32, scaley: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaRotate(ptas: *mut PTA, xc: l_float32, yc: l_float32, angle: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaTranslate(boxas: *mut BOXA, transx: l_float32, transy: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaScale(boxas: *mut BOXA, scalex: l_float32, scaley: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaRotate(
        boxas: *mut BOXA,
        xc: l_float32,
        yc: l_float32,
        angle: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn ptaAffineTransform(ptas: *mut PTA, mat: *mut l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaAffineTransform(boxas: *mut BOXA, mat: *mut l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn l_productMatVec(
        mat: *mut l_float32,
        vecs: *mut l_float32,
        vecd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat2(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat3(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat4(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        mat4: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_getDataBit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_clearDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_setDataBitVal(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataDibit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataQbit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataByte(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataByte(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataTwoBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataFourBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn barcodeDispatchDecoder(
        barstr: *mut ::std::os::raw::c_char,
        format: l_int32,
        debugflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn barcodeFormatIsSupported(format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFindBaselines(pixs: *mut PIX, ppta: *mut *mut PTA, pixadb: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixDeskewLocal(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetLocalSkewTransform(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pptas: *mut *mut PTA,
        pptad: *mut *mut PTA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLocalSkewAngles(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pa: *mut l_float32,
        pb: *mut l_float32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bbufferCreate(indata: *const l_uint8, nalloc: l_int32) -> *mut L_BBUFFER;
}
extern "C" {
    pub fn bbufferDestroy(pbb: *mut *mut L_BBUFFER);
}
extern "C" {
    pub fn bbufferDestroyAndSaveData(
        pbb: *mut *mut L_BBUFFER,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn bbufferRead(bb: *mut L_BBUFFER, src: *mut l_uint8, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferReadStream(bb: *mut L_BBUFFER, fp: *mut FILE, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferExtendArray(bb: *mut L_BBUFFER, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferWrite(
        bb: *mut L_BBUFFER,
        dest: *mut l_uint8,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn bbufferWriteStream(
        bb: *mut L_BBUFFER,
        fp: *mut FILE,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBilateral(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGray(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGrayExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockBilateralExact(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRangeKernel(range_stdev: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn pixBilinearSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinear(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getBilinearXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn bilinearXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bilinearXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuAdaptiveThreshold(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskedThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSauvolaBinarizeTiled(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        nx: l_int32,
        ny: l_int32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaBinarize(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        addborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixsd: *mut *mut PIX,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaOnContrastNorm(
        pixs: *mut PIX,
        mindiff: l_int32,
        ppixn: *mut *mut PIX,
        ppixth: *mut *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThreshOnDoubleNorm(pixs: *mut PIX, mindiff: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdByConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        start: l_int32,
        end: l_int32,
        incr: l_int32,
        thresh48: l_float32,
        threshdiff: l_float32,
        pglobthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixThresholdByHisto(
        pixs: *mut PIX,
        factor: l_int32,
        halfw: l_int32,
        skip: l_int32,
        pthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        pnahisto: *mut *mut NUMA,
        ppixhisto: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExpandBinaryReplicate(pixs: *mut PIX, xfact: l_int32, yfact: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandBinaryPower2(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceBinary2(pixs: *mut PIX, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinaryCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinary2(pixs: *mut PIX, level: l_int32, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn makeSubsampleTab2x() -> *mut l_uint8;
}
extern "C" {
    pub fn pixBlend(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendMask(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGray(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayInverse(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColor(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColorByChannel(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayAdapt(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        shift: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFadeWithGray(
        pixs: *mut PIX,
        pixb: *mut PIX,
        factor: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendHardLight(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendCmap(
        pixs: *mut PIX,
        pixb: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlendWithGrayMask(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        pixg: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBackgroundToColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyByColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAlphaBlendUniform(pixs: *mut PIX, color: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaToBlend(pixs: *mut PIX, fract: l_float32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetAlphaOverWhite(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearEdgeFade(
        pixs: *mut PIX,
        dir: l_int32,
        fadeto: l_int32,
        distfract: l_float32,
        maxfade: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfCreate(dir: *const ::std::os::raw::c_char, fontsize: l_int32) -> *mut L_BMF;
}
extern "C" {
    pub fn bmfDestroy(pbmf: *mut *mut L_BMF);
}
extern "C" {
    pub fn bmfGetPix(bmf: *mut L_BMF, chr: ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn bmfGetWidth(bmf: *mut L_BMF, chr: ::std::os::raw::c_char, pw: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn bmfGetBaseline(
        bmf: *mut L_BMF,
        chr: ::std::os::raw::c_char,
        pbaseline: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetFont(
        dir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
        pbl0: *mut l_int32,
        pbl1: *mut l_int32,
        pbl2: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSaveFont(
        indir: *const ::std::os::raw::c_char,
        outdir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamBmp(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemBmp(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamBmp(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemBmp(pfdata: *mut *mut l_uint8, pfsize: *mut size_t, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn l_bootnum_gen1() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen2() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen3() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen4(nsamp: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn boxCreate(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCreateValid(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCopy(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxClone(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxDestroy(pbox: *mut *mut BOX);
}
extern "C" {
    pub fn boxGetGeometry(
        box_: *const BOX,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetGeometry(box_: *mut BOX, x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxGetSideLocations(
        box_: *const BOX,
        pl: *mut l_int32,
        pr: *mut l_int32,
        pt: *mut l_int32,
        pb: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetSideLocations(
        box_: *mut BOX,
        l: l_int32,
        r: l_int32,
        t: l_int32,
        b: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxIsValid(box_: *mut BOX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaCreate(n: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCopy(boxa: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaDestroy(pboxa: *mut *mut BOXA);
}
extern "C" {
    pub fn boxaAddBox(boxa: *mut BOXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArray(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArrayToSize(boxa: *mut BOXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn boxaGetCount(boxa: *const BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetValidCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetValidBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindInvalidBoxes(boxa: *mut BOXA) -> *mut NUMA;
}
extern "C" {
    pub fn boxaGetBoxGeometry(
        boxa: *mut BOXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIsFull(boxa: *mut BOXA, pfull: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaReplaceBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaInsertBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBox(boxa: *mut BOXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBoxAndSave(boxa: *mut BOXA, index: l_int32, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaSaveValid(boxas: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaInitFull(boxa: *mut BOXA, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaClear(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaCreate(n: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaCopy(baas: *mut BOXAA, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaDestroy(pbaa: *mut *mut BOXAA);
}
extern "C" {
    pub fn boxaaAddBoxa(baa: *mut BOXAA, ba: *mut BOXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArray(baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArrayToSize(baa: *mut BOXAA, size: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxa(baa: *mut BOXAA, index: l_int32, accessflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaGetBox(
        baa: *mut BOXAA,
        iboxa: l_int32,
        ibox: l_int32,
        accessflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaaInitFull(baa: *mut BOXAA, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendWithInit(baa: *mut BOXAA, maxindex: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaReplaceBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaInsertBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaRemoveBoxa(baa: *mut BOXAA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaAddBox(
        baa: *mut BOXAA,
        index: l_int32,
        box_: *mut BOX,
        accessflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadStream(fp: *mut FILE) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaWrite(filename: *const ::std::os::raw::c_char, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteStream(fp: *mut FILE, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadStream(fp: *mut FILE) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWriteDebug(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWrite(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStream(fp: *mut FILE, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStderr(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxPrintStreamInfo(fp: *mut FILE, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxContains(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIntersects(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaContainedInBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBoxa(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        pcontained: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIntersectsBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaIntersectsBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaClipToBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlaps(boxas: *mut BOXA, pixadb: *mut PIXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlapsInPair(
        boxas1: *mut BOXA,
        boxas2: *mut BOXA,
        pboxad1: *mut *mut BOXA,
        pboxad2: *mut *mut BOXA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxOverlapRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxBoundingRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxOverlapFraction(box1: *mut BOX, box2: *mut BOX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxOverlapArea(box1: *mut BOX, box2: *mut BOX, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaHandleOverlaps(
        boxas: *mut BOXA,
        op: l_int32,
        range: l_int32,
        min_overlap: l_float32,
        max_ratio: l_float32,
        pnamap: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxOverlapDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_ovl: *mut l_int32,
        pv_ovl: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSeparationDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_sep: *mut l_int32,
        pv_sep: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxCompareSize(
        box1: *mut BOX,
        box2: *mut BOX,
        type_: l_int32,
        prel: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxContainsPt(
        box_: *mut BOX,
        x: l_float32,
        y: l_float32,
        pcontains: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestToPt(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetNearestToLine(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindNearestBoxes(
        boxa: *mut BOXA,
        dist_select: l_int32,
        range: l_int32,
        pnaaindex: *mut *mut NUMAA,
        pnaadist: *mut *mut NUMAA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestByDirection(
        boxa: *mut BOXA,
        i: l_int32,
        dir: l_int32,
        dist_select: l_int32,
        range: l_int32,
        pindex: *mut l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetCenter(box_: *const BOX, pcx: *mut l_float32, pcy: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxIntersectByLine(
        box_: *const BOX,
        x: l_int32,
        y: l_int32,
        slope: l_float32,
        px1: *mut l_int32,
        py1: *mut l_int32,
        px2: *mut l_int32,
        py2: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxClipToRectangle(box_: *mut BOX, wi: l_int32, hi: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxClipToRectangleParams(
        box_: *mut BOX,
        w: l_int32,
        h: l_int32,
        pxstart: *mut l_int32,
        pystart: *mut l_int32,
        pxend: *mut l_int32,
        pyend: *mut l_int32,
        pbw: *mut l_int32,
        pbh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxRelocateOneSide(
        boxd: *mut BOX,
        boxs: *mut BOX,
        loc: l_int32,
        sideflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaAdjustSides(
        boxas: *mut BOXA,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustBoxSides(
        boxa: *mut BOXA,
        index: l_int32,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxAdjustSides(
        boxd: *mut BOX,
        boxs: *mut BOX,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSetSide(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        side: l_int32,
        val: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxSetSide(boxs: *mut BOX, side: l_int32, val: l_int32, thresh: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaAdjustWidthToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustHeightToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxEqual(box1: *mut BOX, box2: *mut BOX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaEqual(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSimilar(
        box1: *mut BOX,
        box2: *mut BOX,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        psimilar: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSimilar(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        debug: l_int32,
        psimilar: *mut l_int32,
        pnasim: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaJoin(boxad: *mut BOXA, boxas: *mut BOXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaJoin(baad: *mut BOXAA, baas: *mut BOXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaSplitEvenOdd(
        boxa: *mut BOXA,
        fillflag: l_int32,
        pboxae: *mut *mut BOXA,
        pboxao: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMergeEvenOdd(boxae: *mut BOXA, boxao: *mut BOXA, fillflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaTransform(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransform(
        box_: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaTransformOrdered(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransformOrdered(
        boxs: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaRotateOrth(boxas: *mut BOXA, w: l_int32, h: l_int32, rotation: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxRotateOrth(box_: *mut BOX, w: l_int32, h: l_int32, rotation: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaShiftWithPta(boxas: *mut BOXA, pta: *mut PTA, dir: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaBinSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSortByIndex(boxas: *mut BOXA, naindex: *mut NUMA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort2d(
        boxas: *mut BOXA,
        pnaad: *mut *mut NUMAA,
        delta1: l_int32,
        delta2: l_int32,
        minh1: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSort2dByIndex(boxas: *mut BOXA, naa: *mut NUMAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaExtractAsNuma(
        boxa: *mut BOXA,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractAsPta(
        boxa: *mut BOXA,
        pptal: *mut *mut PTA,
        pptat: *mut *mut PTA,
        pptar: *mut *mut PTA,
        pptab: *mut *mut PTA,
        pptaw: *mut *mut PTA,
        pptah: *mut *mut PTA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractCorners(boxa: *mut BOXA, loc: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn boxaGetRankVals(
        boxa: *mut BOXA,
        fract: l_float32,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetMedianVals(
        boxa: *mut BOXA,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetAverageSize(boxa: *mut BOXA, pw: *mut l_float32, ph: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetExtent(
        baa: *mut BOXAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaFlattenToBoxa(
        baa: *mut BOXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaFlattenAligned(
        baa: *mut BOXAA,
        num: l_int32,
        fillerbox: *mut BOX,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaEncapsulateAligned(boxa: *mut BOXA, num: l_int32, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaTranspose(baas: *mut BOXAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaAlignBox(
        baa: *mut BOXAA,
        box_: *mut BOX,
        delta: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMaskConnComp(
        pixs: *mut PIX,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskBoxa(pixd: *mut PIX, pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxa(pixs: *mut PIX, boxa: *mut BOXA, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetBlackOrWhiteBoxa(pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxa(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn boxaaDisplay(
        pixs: *mut PIX,
        baa: *mut BOXAA,
        linewba: l_int32,
        linewb: l_int32,
        colorba: l_uint32,
        colorb: l_uint32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayBoxaa(
        pixas: *mut PIXA,
        baa: *mut BOXAA,
        colorflag: l_int32,
        width: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSplitIntoBoxa(
        pixs: *mut PIX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixSplitComponentIntoBoxa(
        pix: *mut PIX,
        box_: *mut BOX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn makeMosaicStrips(w: l_int32, h: l_int32, direction: l_int32, size: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxaCompareRegions(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        areathresh: l_int32,
        pnsame: *mut l_int32,
        pdiffarea: *mut l_float32,
        pdiffxor: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectLargeULComp(
        pixs: *mut PIX,
        areaslop: l_float32,
        yslop: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectLargeULBox(boxas: *mut BOXA, areaslop: l_float32, yslop: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectRange(
        boxas: *mut BOXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaSelectRange(
        baas: *mut BOXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSelectBySize(
        boxas: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeSizeIndicator(
        boxa: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByArea(
        boxas: *mut BOXA,
        area: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeAreaIndicator(boxa: *mut BOXA, area: l_int32, relation: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByWHRatio(
        boxas: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeWHRatioIndicator(
        boxa: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectWithIndicator(
        boxas: *mut BOXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermutePseudorandom(boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermuteRandom(boxad: *mut BOXA, boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSwapBoxes(boxa: *mut BOXA, i: l_int32, j: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaConvertToPta(boxa: *mut BOXA, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBoxa(pta: *mut PTA, ncorners: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxConvertToPta(box_: *mut BOX, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBox(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetExtent(
        boxa: *mut BOXA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetCoverage(
        boxa: *mut BOXA,
        wc: l_int32,
        hc: l_int32,
        exactflag: l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaSizeRange(
        baa: *mut BOXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSizeRange(
        boxa: *mut BOXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaLocationRange(
        boxa: *mut BOXA,
        pminx: *mut l_int32,
        pminy: *mut l_int32,
        pmaxx: *mut l_int32,
        pmaxy: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetSizes(boxa: *mut BOXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn boxaGetArea(boxa: *mut BOXA, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaDisplayTiled(
        boxas: *mut BOXA,
        pixa: *mut PIXA,
        first: l_int32,
        last: l_int32,
        maxwidth: l_int32,
        linewidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn boxaSmoothSequenceMedian(
        boxas: *mut BOXA,
        halfwin: l_int32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWindowedMedian(boxas: *mut BOXA, halfwin: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaModifyWithBoxa(
        boxas: *mut BOXA,
        boxam: *mut BOXA,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcilePairWidth(
        boxas: *mut BOXA,
        delw: l_int32,
        op: l_int32,
        factor: l_float32,
        na: *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeConsistency(
        boxas: *mut BOXA,
        type_: l_int32,
        threshp: l_float32,
        threshm: l_float32,
        pfvarp: *mut l_float32,
        pfvarm: *mut l_float32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaReconcileAllByMedian(
        boxas: *mut BOXA,
        select1: l_int32,
        select2: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSidesByMedian(
        boxas: *mut BOXA,
        select: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSizeByMedian(
        boxas: *mut BOXA,
        type_: l_int32,
        dfract: l_float32,
        sfract: l_float32,
        factor: l_float32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
        pratiowh: *mut l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPlotSides(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaPlotSizes(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaFillSequence(boxas: *mut BOXA, useflag: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeVariation(
        boxa: *mut BOXA,
        type_: l_int32,
        pdel_evenodd: *mut l_float32,
        prms_even: *mut l_float32,
        prms_odd: *mut l_float32,
        prms_all: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMedianDimensions(
        boxas: *mut BOXA,
        pmedw: *mut l_int32,
        pmedh: *mut l_int32,
        pmedwe: *mut l_int32,
        pmedwo: *mut l_int32,
        pmedhe: *mut l_int32,
        pmedho: *mut l_int32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaCreate(nbytes: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromMem(data: *const l_uint8, size: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromFile(fname: *const ::std::os::raw::c_char) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromStream(fp: *mut FILE) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaCopy(bas: *mut L_BYTEA, copyflag: l_int32) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaDestroy(pba: *mut *mut L_BYTEA);
}
extern "C" {
    pub fn l_byteaGetSize(ba: *mut L_BYTEA) -> size_t;
}
extern "C" {
    pub fn l_byteaGetData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaCopyData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaAppendData(ba: *mut L_BYTEA, newdata: *const l_uint8, newbytes: size_t) -> l_ok;
}
extern "C" {
    pub fn l_byteaAppendString(ba: *mut L_BYTEA, str_: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn l_byteaJoin(ba1: *mut L_BYTEA, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaSplit(ba1: *mut L_BYTEA, splitloc: size_t, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaFindEachSequence(
        ba: *mut L_BYTEA,
        sequence: *const l_uint8,
        seqlen: size_t,
        pda: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWrite(
        fname: *const ::std::os::raw::c_char,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWriteStream(
        fp: *mut FILE,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn ccbaDestroy(pccba: *mut *mut CCBORDA);
}
extern "C" {
    pub fn pixGetAllCCBorders(pixs: *mut PIX) -> *mut CCBORDA;
}
extern "C" {
    pub fn pixGetOuterBordersPtaa(pixs: *mut PIX) -> *mut PTAA;
}
extern "C" {
    pub fn pixGetOuterBorder(ccb: *mut CCBORD, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateGlobalLocs(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateStepChains(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaStepChainsToPixCoords(ccba: *mut CCBORDA, coordtype: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSPGlobalLocs(ccba: *mut CCBORDA, ptsflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSinglePath(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaDisplayBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplaySPBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage1(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage2(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaWrite(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteStream(fp: *mut FILE, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaRead(filename: *const ::std::os::raw::c_char) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaReadStream(fp: *mut FILE) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaWriteSVG(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteSVGString(ccba: *mut CCBORDA) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixaThinConnected(
        pixas: *mut PIXA,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixThinConnected(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThinConnectedBySet(
        pixs: *mut PIX,
        type_: l_int32,
        sela: *mut SELA,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaMakeThinSets(index: l_int32, debug: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn pixFindCheckerboardCorners(
        pixs: *mut PIX,
        size: l_int32,
        dilation: l_int32,
        nsels: l_int32,
        ppix_corners: *mut *mut PIX,
        ppta_corners: *mut *mut PTA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbCorrelation(
        dirin: *const ::std::os::raw::c_char,
        thresh: l_float32,
        weight: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbRankHaus(
        dirin: *const ::std::os::raw::c_char,
        size: l_int32,
        rank: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbWordsInTextlines(
        dirin: *const ::std::os::raw::c_char,
        reduction: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weight: l_float32,
        pnatl: *mut *mut NUMA,
        firstpage: l_int32,
        npages: l_int32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn pixGetWordsInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetWordBoxesInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindWordAndCharacterBoxes(
        pixs: *mut PIX,
        boxs: *mut BOX,
        thresh: l_int32,
        pboxaw: *mut *mut BOXA,
        pboxaac: *mut *mut BOXAA,
        debugdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractSortedPattern(boxa: *mut BOXA, na: *mut NUMA) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCompareImagesByBoxes(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        nperline: l_int32,
        nreq: l_int32,
        maxshiftx: l_int32,
        maxshifty: l_int32,
        delx: l_int32,
        dely: l_int32,
        psame: *mut l_int32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorContent(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        mingray: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorMagnitude(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorFraction(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        factor: l_int32,
        ppixfract: *mut l_float32,
        pcolorfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorShiftWhitePoint(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorPixels(
        pixs: *mut PIX,
        threshdiff: l_int32,
        mindist: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverGrayPixels(pixs: *mut PIX, maxlimit: l_int32, satlimit: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorRange(
        pixs: *mut PIX,
        rmin: l_int32,
        rmax: l_int32,
        gmin: l_int32,
        gmax: l_int32,
        bmin: l_int32,
        bmax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindColorRegions(
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_int32,
        lightthresh: l_int32,
        darkthresh: l_int32,
        mindiff: l_int32,
        colordiff: l_int32,
        edgefract: l_float32,
        pcolorfract: *mut l_float32,
        pcolormask1: *mut *mut PIX,
        pcolormask2: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumSignificantGrayColors(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        minfract: l_float32,
        factor: l_int32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorsForQuantization(
        pixs: *mut PIX,
        thresh: l_int32,
        pncolors: *mut l_int32,
        piscolor: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToCmapLossless(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetMostPopulatedColors(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
        parray: *mut *mut l_uint32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSimpleColorQuantize(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBHistogram(pixs: *mut PIX, sigbits: l_int32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn makeRGBIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        sigbits: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn getRGBFromIndex(
        index: l_uint32,
        sigbits: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHasHighlightRed(
        pixs: *mut PIX,
        factor: l_int32,
        minfract: l_float32,
        fthresh: l_float32,
        phasred: *mut l_int32,
        pratio: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_colorfillCreate(pixs: *mut PIX, nx: l_int32, ny: l_int32) -> *mut L_COLORFILL;
}
extern "C" {
    pub fn l_colorfillDestroy(pcf: *mut *mut L_COLORFILL);
}
extern "C" {
    pub fn pixColorContentByLocation(
        cf: *mut L_COLORFILL,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        minmax: l_int32,
        maxdiff: l_int32,
        minarea: l_int32,
        smooth: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorFill(
        pixs: *mut PIX,
        minmax: l_int32,
        maxdiff: l_int32,
        smooth: l_int32,
        minarea: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeColorfillTestData(
        w: l_int32,
        h: l_int32,
        nseeds: l_int32,
        range: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixColorGrayRegions(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorGray(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColorCmap(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearMapToTargetColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelLinearMapToTargetColor(
        scolor: l_uint32,
        srcmap: l_uint32,
        dstmap: l_uint32,
        pdcolor: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixShiftByComponent(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelShiftByComponent(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        srcval: l_uint32,
        dstval: l_uint32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixelFractionalShift(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMapWithInvariantHue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixcmapCreate(depth: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateRandom(
        depth: l_int32,
        hasblack: l_int32,
        haswhite: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateLinear(d: l_int32, nlevels: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCopy(cmaps: *const PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapDestroy(pcmap: *mut *mut PIXCMAP);
}
extern "C" {
    pub fn pixcmapIsValid(cmap: *const PIXCMAP, pix: *mut PIX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddColor(cmap: *mut PIXCMAP, rval: l_int32, gval: l_int32, bval: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapAddRGBA(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNewColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNearestColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapUsableColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pusable: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddBlackOrWhite(cmap: *mut PIXCMAP, color: l_int32, pindex: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapSetBlackAndWhite(
        cmap: *mut PIXCMAP,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetCount(cmap: *const PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetFreeCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDepth(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetMinDepth(cmap: *mut PIXCMAP, pmindepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapClear(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapResetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSetAlpha(cmap: *mut PIXCMAP, index: l_int32, aval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapHasColor(cmap: *mut PIXCMAP, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsOpaque(cmap: *mut PIXCMAP, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapNonOpaqueColorsInfo(
        cmap: *mut PIXCMAP,
        pntrans: *mut l_int32,
        pmax_trans: *mut l_int32,
        pmin_opaque: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsBlackAndWhite(cmap: *mut PIXCMAP, pblackwhite: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapCountGrayColors(cmap: *mut PIXCMAP, pngray: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRankIntensity(
        cmap: *mut PIXCMAP,
        rankval: l_float32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestGrayIndex(
        cmap: *mut PIXCMAP,
        val: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetDistanceToColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRangeValues(
        cmap: *mut PIXCMAP,
        select: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pminindex: *mut l_int32,
        pmaxindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGrayToFalseColor(gamma: l_float32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapGrayToColor(color: l_uint32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapColorToGray(
        cmaps: *mut PIXCMAP,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo4(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo8(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapRead(filename: *const ::std::os::raw::c_char) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadStream(fp: *mut FILE) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadMem(data: *const l_uint8, size: size_t) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapWrite(filename: *const ::std::os::raw::c_char, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteStream(fp: *mut FILE, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        cmap: *const PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToArrays(
        cmap: *const PIXCMAP,
        prmap: *mut *mut l_int32,
        pgmap: *mut *mut l_int32,
        pbmap: *mut *mut l_int32,
        pamap: *mut *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToRGBTable(
        cmap: *mut PIXCMAP,
        ptab: *mut *mut l_uint32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSerializeToMemory(
        cmap: *mut PIXCMAP,
        cpc: l_int32,
        pncolors: *mut l_int32,
        pdata: *mut *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapDeserializeFromMemory(
        data: *mut l_uint8,
        cpc: l_int32,
        ncolors: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertToHex(data: *mut l_uint8, ncolors: l_int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixcmapGammaTRC(
        cmap: *mut PIXCMAP,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapContrastTRC(cmap: *mut PIXCMAP, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftIntensity(cmap: *mut PIXCMAP, fraction: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftByComponent(cmap: *mut PIXCMAP, srcval: l_uint32, dstval: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixColorMorph(
        pixs: *mut PIX,
        type_: l_int32,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuant(pixs: *mut PIX, colors: l_int32, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuantGeneral(
        pixs: *mut PIX,
        colors: l_int32,
        ditherflag: l_int32,
        validthresh: l_float32,
        colorthresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRGBToIndexTables(
        cqlevels: l_int32,
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn getOctcubeIndexFromRGB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        rtab: *mut l_uint32,
        gtab: *mut l_uint32,
        btab: *mut l_uint32,
        pindex: *mut l_uint32,
    );
}
extern "C" {
    pub fn pixOctreeQuantByPopulation(
        pixs: *mut PIX,
        level: l_int32,
        ditherflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeQuantNumColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        subsample: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantMixedWithGray(
        pixs: *mut PIX,
        depth: l_int32,
        graylevels: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuant256(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant1(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant2(
        pixs: *mut PIX,
        level: l_int32,
        na: *mut NUMA,
        ncolors: l_int32,
        pnerrors: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuantMixed(
        pixs: *mut PIX,
        level: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        minfract: l_float32,
        maxspan: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuantGenRGB(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeHistogram(pixs: *mut PIX, level: l_int32, pncolors: *mut l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixcmapToOctcubeLUT(cmap: *mut PIXCMAP, level: l_int32, metric: l_int32)
        -> *mut l_int32;
}
extern "C" {
    pub fn pixRemoveUnusedColors(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixNumberOccupiedOctcubes(
        pix: *mut PIX,
        level: l_int32,
        mincount: l_int32,
        minfract: l_float32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMedianCutQuant(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantGeneral(
        pixs: *mut PIX,
        ditherflag: l_int32,
        outdepth: l_int32,
        maxcolors: l_int32,
        sigbits: l_int32,
        maxsub: l_int32,
        checkbw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        maxncolors: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutHisto(pixs: *mut PIX, sigbits: l_int32, subsample: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn pixColorSegment(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        selsize: l_int32,
        finalcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorSegmentCluster(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAssignToNearestColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        level: l_int32,
        countarray: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentClean(pixs: *mut PIX, selsize: l_int32, countarray: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentRemoveColors(
        pixd: *mut PIX,
        pixs: *mut PIX,
        finalcolors: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHSV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertHSVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToHSV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        phval: *mut l_int32,
        psval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertHSVToRGB(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToHSV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertHSVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToSaturation(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToValue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHS(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        satcenter: l_int32,
        sathw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHV(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskSV(
        pixs: *mut PIX,
        satcenter: l_int32,
        sathw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHS(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnasat: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHV(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoSV(
        pixs: *mut PIX,
        factor: l_int32,
        pnasat: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHistoPeaksHSV(
        pixs: *mut PIX,
        type_: l_int32,
        width: l_int32,
        height: l_int32,
        npeaks: l_int32,
        erasefactor: l_float32,
        ppta: *mut *mut PTA,
        pnatot: *mut *mut NUMA,
        ppixa: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn displayHSVColorRange(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        huehw: l_int32,
        sathw: l_int32,
        nsamp: l_int32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToYUV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertYUVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToYUV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pyval: *mut l_int32,
        puval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertYUVToRGB(
        yval: l_int32,
        uval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToYUV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertYUVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToXYZ(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertXYZToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToXYZ(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pfxval: *mut l_float32,
        pfyval: *mut l_float32,
        pfzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertXYZToRGB(
        fxval: l_float32,
        fyval: l_float32,
        fzval: l_float32,
        blackout: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaConvertXYZToLAB(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToXYZ(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn convertXYZToLAB(
        xval: l_float32,
        yval: l_float32,
        zval: l_float32,
        plval: *mut l_float32,
        paval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToXYZ(
        lval: l_float32,
        aval: l_float32,
        bval: l_float32,
        pxval: *mut l_float32,
        pyval: *mut l_float32,
        pzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToLAB(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToLAB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pflval: *mut l_float32,
        pfaval: *mut l_float32,
        pfbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToRGB(
        flval: l_float32,
        faval: l_float32,
        fbval: l_float32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeGamutRGB(scale: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixEqual(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithAlpha(
        pix1: *mut PIX,
        pix2: *mut PIX,
        use_alpha: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithCmap(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn cmapEqual(
        cmap1: *mut PIXCMAP,
        cmap2: *mut PIXCMAP,
        ncomps: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUsesCmapColor(pixs: *mut PIX, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationBinary(pix1: *mut PIX, pix2: *mut PIX, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayDiffBinary(pix1: *mut PIX, pix2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCompareBinary(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        pfract: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayOrRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGray(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareTiled(
        pix1: *mut PIX,
        pix2: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRankDifference(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTestForSimilarity(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        maxfract: l_float32,
        maxave: l_float32,
        psimilar: *mut l_int32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceStats(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        pfractdiff: *mut l_float32,
        pavediff: *mut l_float32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceHistogram(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetPerceptualDiff(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        sampling: l_int32,
        dilation: l_int32,
        mindiff: l_int32,
        pfract: *mut l_float32,
        ppixdiff1: *mut *mut PIX,
        ppixdiff2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPSNR(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        ppsnr: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaComparePhotoRegionsByHisto(
        pixa: *mut PIXA,
        minratio: l_float32,
        textthresh: l_float32,
        factor: l_int32,
        n: l_int32,
        simthresh: l_float32,
        pnai: *mut *mut NUMA,
        pscores: *mut *mut l_float32,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixComparePhotoRegionsByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenPhotoHistos(
        pixs: *mut PIX,
        box_: *mut BOX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        debugindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPadToCenterCentroid(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCentroid8(
        pixs: *mut PIX,
        factor: l_int32,
        pcx: *mut l_float32,
        pcy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfPhotoImage(
        pix: *mut PIX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn compareTilesByHisto(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        minratio: l_float32,
        w1: l_int32,
        h1: l_int32,
        w2: l_int32,
        h2: l_int32,
        pscore: *mut l_float32,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        maxgray: l_int32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropAlignedToCentroid(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        pbox1: *mut *mut BOX,
        pbox2: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_compressGrayHistograms(
        naa: *mut NUMAA,
        w: l_int32,
        h: l_int32,
        psize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_uncompressGrayHistograms(
        bytea: *mut l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixCompareWithTranslation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        thresh: l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBestCorrelation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        etransx: l_int32,
        etransy: l_int32,
        maxshift: l_int32,
        tab8: *mut l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnComp(pixs: *mut PIX, ppixa: *mut *mut PIXA, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompPixa(
        pixs: *mut PIX,
        ppixa: *mut *mut PIXA,
        connectivity: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompBB(pixs: *mut PIX, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixCountConnComp(pixs: *mut PIX, connectivity: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn nextOnPixelInRaster(
        pixs: *mut PIX,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillBB(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill4BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill8BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill4(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill8(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn convertFilesTo1bpp(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        upscaling: l_int32,
        thresh: l_int32,
        firstpage: l_int32,
        npages: l_int32,
        dirout: *const ::std::os::raw::c_char,
        outformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlockconv(pix: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGray(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvAccum(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayUnnormalized(pixs: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvTiled(
        pix: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayTile(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedStats(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixms: *mut *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWindowedMean(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedMeanSquare(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedVariance(
        pixm: *mut PIX,
        pixms: *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanSquareAccum(pixs: *mut PIX) -> *mut DPIX;
}
extern "C" {
    pub fn pixBlockrank(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlocksum(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCensusTransform(pixs: *mut PIX, halfsize: l_int32, pixacc: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolve(
        pixs: *mut PIX,
        kel: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveSep(
        pixs: *mut PIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGB(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGBSep(pixs: *mut PIX, kelx: *mut L_KERNEL, kely: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvolve(fpixs: *mut FPIX, kel: *mut L_KERNEL, normflag: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixConvolveSep(
        fpixs: *mut FPIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        normflag: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvolveWithBias(
        pixs: *mut PIX,
        kel1: *mut L_KERNEL,
        kel2: *mut L_KERNEL,
        force8: l_int32,
        pbias: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setConvolveSampling(xfact: l_int32, yfact: l_int32);
}
extern "C" {
    pub fn pixAddGaussianNoise(pixs: *mut PIX, stdev: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn gaussDistribSampling() -> l_float32;
}
extern "C" {
    pub fn pixCorrelationScore(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreThresholded(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        downcount: *mut l_int32,
        score_threshold: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreSimple(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreShifted(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_int32,
        dely: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpCreate(pixs: *mut PIX, pageno: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpCreateRef(pageno: l_int32, refpage: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpDestroy(pdew: *mut *mut L_DEWARP);
}
extern "C" {
    pub fn dewarpaCreate(
        nptrs: l_int32,
        sampling: l_int32,
        redfactor: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaCreateFromPixacomp(
        pixac: *mut PIXAC,
        useboth: l_int32,
        sampling: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaDestroy(pdewa: *mut *mut L_DEWARPA);
}
extern "C" {
    pub fn dewarpaDestroyDewarp(dewa: *mut L_DEWARPA, pageno: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertDewarp(dewa: *mut L_DEWARPA, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpaGetDewarp(dewa: *mut L_DEWARPA, index: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpaSetCurvatures(
        dewa: *mut L_DEWARPA,
        max_linecurv: l_int32,
        min_diff_linecurv: l_int32,
        max_diff_linecurv: l_int32,
        max_edgecurv: l_int32,
        max_diff_edgecurv: l_int32,
        max_edgeslope: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaUseBothArrays(dewa: *mut L_DEWARPA, useboth: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetCheckColumns(dewa: *mut L_DEWARPA, check_columns: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetMaxDistance(dewa: *mut L_DEWARPA, maxdist: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadStream(fp: *mut FILE) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpWrite(filename: *const ::std::os::raw::c_char, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteStream(fp: *mut FILE, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dew: *mut L_DEWARP)
        -> l_ok;
}
extern "C" {
    pub fn dewarpaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadStream(fp: *mut FILE) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaWrite(filename: *const ::std::os::raw::c_char, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteStream(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        dewa: *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildPageModel(
        dew: *mut L_DEWARP,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpFindVertDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA, rotflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpFindHorizDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn dewarpGetTextlineCenters(pixs: *mut PIX, debugflag: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpRemoveShortLines(
        pixs: *mut PIX,
        ptaas: *mut PTAA,
        fract: l_float32,
        debugflag: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpFindHorizSlopeDisparity(
        dew: *mut L_DEWARP,
        pixb: *mut PIX,
        fractthresh: l_float32,
        parity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildLineModel(
        dew: *mut L_DEWARP,
        opensize: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStatus(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pvsuccess: *mut l_int32,
        phsuccess: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparity(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        grayin: l_int32,
        x: l_int32,
        y: l_int32,
        ppixd: *mut *mut PIX,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparityBoxa(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        mapdir: l_int32,
        x: l_int32,
        y: l_int32,
        pboxad: *mut *mut BOXA,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpMinimize(dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpPopulateFullRes(dew: *mut L_DEWARP, pix: *mut PIX, x: l_int32, y: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePage(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixd: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageInit(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixb: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageRun(
        pixs: *mut PIX,
        pixb: *mut PIX,
        dewa: *mut L_DEWARPA,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaListPages(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetValidModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertRefModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaStripRefModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaRestoreModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaInfo(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStats(
        dewa: *mut L_DEWARPA,
        pnnone: *mut l_int32,
        pnvsuccess: *mut l_int32,
        pnvvalid: *mut l_int32,
        pnhsuccess: *mut l_int32,
        pnhvalid: *mut l_int32,
        pnref: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaShowArrays(
        dewa: *mut L_DEWARPA,
        scalefact: l_float32,
        first: l_int32,
        last: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpDebug(
        dew: *mut L_DEWARP,
        subdirs: *const ::std::os::raw::c_char,
        index: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpShowResults(
        dewa: *mut L_DEWARPA,
        sa: *mut SARRAY,
        boxa: *mut BOXA,
        firstpage: l_int32,
        lastpage: l_int32,
        pdfout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaCreate(n: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromDArray(
        darray: *mut l_float64,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaMakeSequence(
        startval: l_float64,
        increment: l_float64,
        size: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaDestroy(pda: *mut *mut L_DNA);
}
extern "C" {
    pub fn l_dnaCopy(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaClone(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaEmpty(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaAddNumber(da: *mut L_DNA, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaInsertNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaRemoveNumber(da: *mut L_DNA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaReplaceNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetCount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetCount(da: *mut L_DNA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetDValue(da: *mut L_DNA, index: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIValue(da: *mut L_DNA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetValue(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaShiftValue(da: *mut L_DNA, index: l_int32, diff: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIArray(da: *mut L_DNA) -> *mut l_int32;
}
extern "C" {
    pub fn l_dnaGetDArray(da: *mut L_DNA, copyflag: l_int32) -> *mut l_float64;
}
extern "C" {
    pub fn l_dnaGetParameters(
        da: *mut L_DNA,
        pstartx: *mut l_float64,
        pdelx: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetParameters(da: *mut L_DNA, startx: l_float64, delx: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaCopyParameters(dad: *mut L_DNA, das: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadStream(fp: *mut FILE) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaWrite(filename: *const ::std::os::raw::c_char, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStream(fp: *mut FILE, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStderr(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaCreate(n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaCreateFull(nptr: l_int32, n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaTruncate(daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaDestroy(pdaa: *mut *mut L_DNAA);
}
extern "C" {
    pub fn l_dnaaAddDna(daa: *mut L_DNAA, da: *mut L_DNA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDnaCount(daa: *mut L_DNAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetNumberCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDna(daa: *mut L_DNAA, index: l_int32, accessflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaaReplaceDna(daa: *mut L_DNAA, index: l_int32, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetValue(daa: *mut L_DNAA, i: l_int32, j: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaAddNumber(daa: *mut L_DNAA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadStream(fp: *mut FILE) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaWrite(filename: *const ::std::os::raw::c_char, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteStream(fp: *mut FILE, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaJoin(dad: *mut L_DNA, das: *mut L_DNA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaFlattenToDna(daa: *mut L_DNAA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaSelectRange(das: *mut L_DNA, first: l_int32, last: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaConvertToNuma(da: *mut L_DNA) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToDna(na: *mut NUMA) -> *mut L_DNA;
}
extern "C" {
    pub fn pixConvertDataToDna(pix: *mut PIX) -> *mut L_DNA;
}
extern "C" {
    pub fn l_asetCreateFromDna(da: *mut L_DNA) -> *mut L_ASET;
}
extern "C" {
    pub fn l_dnaRemoveDupsByAset(das: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromDna(da: *mut L_DNA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_dnaRemoveDupsByHmap(
        das: *mut L_DNA,
        pdad: *mut *mut L_DNA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_dnaMakeHistoByHmap(
        das: *mut L_DNA,
        pdav: *mut *mut L_DNA,
        pdac: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaDiffAdjValues(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashCreate(nbuckets: l_int32, initsize: l_int32) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaHashDestroy(pdahash: *mut *mut L_DNAHASH);
}
extern "C" {
    pub fn l_dnaHashGetDna(dahash: *mut L_DNAHASH, key: l_uint64, copyflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashAdd(dahash: *mut L_DNAHASH, key: l_uint64, value: l_float64) -> l_ok;
}
extern "C" {
    pub fn pixMorphDwa_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_2(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSobelEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTwoSidedEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureEdgeSmoothness(
        pixs: *mut PIX,
        side: l_int32,
        minjump: l_int32,
        minreversal: l_int32,
        pjpl: *mut l_float32,
        pjspl: *mut l_float32,
        prpl: *mut l_float32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetEdgeProfile(
        pixs: *mut PIX,
        side: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetLastOffPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLastOnPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn encodeBase64(
        inarray: *const l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeBase64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85(
        inarray: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85(
        inarray: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85WithComp(
        indata: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85WithComp(
        instr: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn reformatPacked64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        leadspace: l_int32,
        linechars: l_int32,
        addquotes: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixGammaTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCWithAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaGammaTRC(gamma: l_float32, minval: l_int32, maxval: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixContrastTRC(pixd: *mut PIX, pixs: *mut PIX, factor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaContrastTRC(factor: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn pixEqualizeTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        fract: l_float32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaEqualizeTRC(pix: *mut PIX, fract: l_float32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTRCMap(pixs: *mut PIX, pixm: *mut PIX, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixTRCMapGeneral(
        pixs: *mut PIX,
        pixm: *mut PIX,
        nar: *mut NUMA,
        nag: *mut NUMA,
        nab: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUnsharpMasking(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGrayFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray1D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray2D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixModifyHue(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixModifySaturation(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureSaturation(pixs: *mut PIX, factor: l_int32, psat: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixModifyBrightness(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMosaicColorShiftRGB(
        pixs: *mut PIX,
        roff: l_float32,
        goff: l_float32,
        boff: l_float32,
        delta: l_float32,
        nincr: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorShiftRGB(
        pixs: *mut PIX,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDarkenGray(
        pixd: *mut PIX,
        pixs: *mut PIX,
        thresh: l_int32,
        satlimit: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultConstantColor(
        pixs: *mut PIX,
        rfact: l_float32,
        gfact: l_float32,
        bfact: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultMatrixColor(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHalfEdgeByBandpass(
        pixs: *mut PIX,
        sm1h: l_int32,
        sm1v: l_int32,
        sm2h: l_int32,
        sm2v: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHMTDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFHMTGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixItalicWords(
        pixs: *mut PIX,
        boxaw: *mut BOXA,
        pixw: *mut PIX,
        pboxa: *mut *mut BOXA,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOrientCorrect(
        pixs: *mut PIX,
        minupconf: l_float32,
        minratio: l_float32,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        protation: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOrientDetect(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeOrientDecision(
        upconf: l_float32,
        leftconf: l_float32,
        minupconf: l_float32,
        minratio: l_float32,
        porient: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUpDownDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMirrorDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixCreate(width: l_int32, height: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCreateTemplate(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixClone(fpix: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCopy(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixDestroy(pfpix: *mut *mut FPIX);
}
extern "C" {
    pub fn fpixGetDimensions(fpix: *mut FPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetDimensions(fpix: *mut FPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetWpl(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixSetWpl(fpix: *mut FPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetResolution(fpix: *mut FPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetResolution(fpix: *mut FPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixCopyResolution(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixGetData(fpix: *mut FPIX) -> *mut l_float32;
}
extern "C" {
    pub fn fpixSetData(fpix: *mut FPIX, data: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixGetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixSetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixaCreate(n: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaCopy(fpixa: *mut FPIXA, copyflag: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaDestroy(pfpixa: *mut *mut FPIXA);
}
extern "C" {
    pub fn fpixaAddFPix(fpixa: *mut FPIXA, fpix: *mut FPIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetCount(fpixa: *mut FPIXA) -> l_int32;
}
extern "C" {
    pub fn fpixaGetFPix(fpixa: *mut FPIXA, index: l_int32, accesstype: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixaGetFPixDimensions(
        fpixa: *mut FPIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaGetData(fpixa: *mut FPIXA, index: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn fpixaGetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaSetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        val: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixCreate(width: l_int32, height: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCreateTemplate(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixClone(dpix: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCopy(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixDestroy(pdpix: *mut *mut DPIX);
}
extern "C" {
    pub fn dpixGetDimensions(dpix: *mut DPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetDimensions(dpix: *mut DPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetWpl(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixSetWpl(dpix: *mut DPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetResolution(dpix: *mut DPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetResolution(dpix: *mut DPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixCopyResolution(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixGetData(dpix: *mut DPIX) -> *mut l_float64;
}
extern "C" {
    pub fn dpixSetData(dpix: *mut DPIX, data: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixGetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixSetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixRead(filename: *const ::std::os::raw::c_char) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadStream(fp: *mut FILE) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadMem(data: *const l_uint8, size: size_t) -> *mut FPIX;
}
extern "C" {
    pub fn fpixWrite(filename: *const ::std::os::raw::c_char, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteStream(fp: *mut FILE, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixEndianByteSwap(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn dpixRead(filename: *const ::std::os::raw::c_char) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadStream(fp: *mut FILE) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadMem(data: *const l_uint8, size: size_t) -> *mut DPIX;
}
extern "C" {
    pub fn dpixWrite(filename: *const ::std::os::raw::c_char, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteStream(fp: *mut FILE, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixEndianByteSwap(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn fpixPrintStream(fp: *mut FILE, fpix: *mut FPIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertToFPix(pixs: *mut PIX, ncomps: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvertToDPix(pixs: *mut PIX, ncomps: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixConvertToPix(
        fpixs: *mut FPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixDisplayMaxDynamicRange(fpixs: *mut FPIX) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvertToDPix(fpix: *mut FPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixConvertToPix(
        dpixs: *mut DPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn dpixConvertToFPix(dpix: *mut DPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixGetMin(
        fpix: *mut FPIX,
        pminval: *mut l_float32,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixGetMax(
        fpix: *mut FPIX,
        pmaxval: *mut l_float32,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMin(
        dpix: *mut DPIX,
        pminval: *mut l_float64,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMax(
        dpix: *mut DPIX,
        pmaxval: *mut l_float64,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixScaleByInteger(fpixs: *mut FPIX, factor: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn dpixScaleByInteger(dpixs: *mut DPIX, factor: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixLinearCombination(
        fpixd: *mut FPIX,
        fpixs1: *mut FPIX,
        fpixs2: *mut FPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMultConstant(fpix: *mut FPIX, addc: l_float32, multc: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixLinearCombination(
        dpixd: *mut DPIX,
        dpixs1: *mut DPIX,
        dpixs2: *mut DPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut DPIX;
}
extern "C" {
    pub fn dpixAddMultConstant(dpix: *mut DPIX, addc: l_float64, multc: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixSetAllArbitrary(fpix: *mut FPIX, inval: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixSetAllArbitrary(dpix: *mut DPIX, inval: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixAddBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRemoveBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMirroredBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddContinuedBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddSlopeBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRasterop(
        fpixd: *mut FPIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        fpixs: *mut FPIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixRotateOrth(fpixs: *mut FPIX, quads: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate180(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate90(fpixs: *mut FPIX, direction: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipLR(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipTB(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffinePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffine(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjectivePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjective(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn linearInterpolatePixelFloat(
        datas: *mut l_float32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        inval: l_float32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixThresholdToPix(fpix: *mut FPIX, thresh: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixComponentFunction(
        pix: *mut PIX,
        rnum: l_float32,
        gnum: l_float32,
        bnum: l_float32,
        rdenom: l_float32,
        gdenom: l_float32,
        bdenom: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixReadStreamGif(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemGif(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamGif(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemGif(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn gplotCreate(
        rootname: *const ::std::os::raw::c_char,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotDestroy(pgplot: *mut *mut GPLOT);
}
extern "C" {
    pub fn gplotAddPlot(
        gplot: *mut GPLOT,
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        plotlabel: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSetScaling(gplot: *mut GPLOT, scaling: l_int32) -> l_ok;
}
extern "C" {
    pub fn gplotMakeOutputPix(gplot: *mut GPLOT) -> *mut PIX;
}
extern "C" {
    pub fn gplotMakeOutput(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenCommandFile(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenDataFiles(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotSimple1(
        na: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimple2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimpleN(
        naa: *mut NUMAA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimplePix1(na: *mut NUMA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        title: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePixN(naa: *mut NUMAA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimpleXY1(
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXY2(
        nax: *mut NUMA,
        nay1: *mut NUMA,
        nay2: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXYN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotGeneralPix1(
        na: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPixN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotRead(filename: *const ::std::os::raw::c_char) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotWrite(filename: *const ::std::os::raw::c_char, gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn generatePtaLine(x1: l_int32, y1: l_int32, x2: l_int32, y2: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaWideLine(
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBox(box_: *mut BOX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBoxa(boxa: *mut BOXA, width: l_int32, removedups: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBox(
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaaBoxa(boxa: *mut BOXA) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaPolyline(
        ptas: *mut PTA,
        width: l_int32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaGrid(
        w: l_int32,
        h: l_int32,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn convertPtaLineTo4cc(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledCircle(radius: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledSquare(side: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaLineFromPt(
        x: l_int32,
        y: l_int32,
        length: l_float64,
        radang: l_float64,
    ) -> *mut PTA;
}
extern "C" {
    pub fn locatePtRadially(
        xr: l_int32,
        yr: l_int32,
        dist: l_float64,
        radang: l_float64,
        px: *mut l_float64,
        py: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPlotFromNuma(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNuma(
        na: *mut NUMA,
        size: l_int32,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPlotFromNumaGen(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNumaGen(
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPta(pix: *mut PIX, pta: *mut PTA, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaArb(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaBlend(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineArb(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineBlend(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBox(pix: *mut PIX, box_: *mut BOX, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxa(pix: *mut PIX, boxa: *mut BOXA, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBox(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashMaskArb(
        pix: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxa(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolyline(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        op: l_int32,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineArb(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineBlend(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderGridArb(
        pix: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderRandomCmapPtaa(
        pix: *mut PIX,
        ptaa: *mut PTAA,
        polyflag: l_int32,
        width: l_int32,
        closeflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderPolygon(
        ptas: *mut PTA,
        width: l_int32,
        pxmin: *mut l_int32,
        pymin: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFillPolygon(pixs: *mut PIX, pta: *mut PTA, xmin: l_int32, ymin: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderContours(
        pixs: *mut PIX,
        startval: l_int32,
        incr: l_int32,
        outdepth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixAutoRenderContours(fpix: *mut FPIX, ncontours: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn fpixRenderContours(fpixs: *mut FPIX, incr: l_float32, proxim: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixGeneratePtaBoundary(pixs: *mut PIX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn pixErodeGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinary(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinarySpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ditherToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        bufs1: *mut l_uint32,
        bufs2: *mut l_uint32,
        lowerclip: l_int32,
        upperclip: l_int32,
        lastlineflag: l_int32,
    );
}
extern "C" {
    pub fn pixThresholdToBinary(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn thresholdToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        lines: *mut l_uint32,
        d: l_int32,
        thresh: l_int32,
    );
}
extern "C" {
    pub fn pixVarThresholdToBinary(pixs: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinary(pixs: *mut PIX, pixm: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinaryGen(
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByValue(pixs: *mut PIX, val: l_int32, usecmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByBand(
        pixs: *mut PIX,
        lower: l_int32,
        upper: l_int32,
        inband: l_int32,
        usecmap: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bpp(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bppSpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo2bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo4bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdOn8bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdGrayArb(
        pixs: *mut PIX,
        edgevals: *const ::std::os::raw::c_char,
        outdepth: l_int32,
        use_average: l_int32,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeGrayQuantIndexTable(nlevels: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn makeGrayQuantTableArb(
        na: *mut NUMA,
        outdepth: l_int32,
        ptab: *mut *mut l_int32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenerateMaskByBand32(
        pixs: *mut PIX,
        refval: l_uint32,
        delm: l_int32,
        delp: l_int32,
        fractm: l_float32,
        fractp: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByDiscr32(
        pixs: *mut PIX,
        refval1: l_uint32,
        refval2: l_uint32,
        distflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromHisto(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        minfract: l_float32,
        maxsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromCmap(pixs: *mut PIX, cmap: *mut PIXCMAP, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn l_hmapCreate(ninit: l_int32, maxocc: l_int32) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_hmapDestroy(phmap: *mut *mut L_HASHMAP);
}
extern "C" {
    pub fn l_hmapLookup(
        hmap: *mut L_HASHMAP,
        key: l_uint64,
        val: l_uint64,
        op: l_int32,
    ) -> *mut L_HASHITEM;
}
extern "C" {
    pub fn l_hmapRehash(hmap: *mut L_HASHMAP) -> l_ok;
}
extern "C" {
    pub fn lheapCreate(n: l_int32, direction: l_int32) -> *mut L_HEAP;
}
extern "C" {
    pub fn lheapDestroy(plh: *mut *mut L_HEAP, freeflag: l_int32);
}
extern "C" {
    pub fn lheapAdd(lh: *mut L_HEAP, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lheapRemove(lh: *mut L_HEAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapGetCount(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapGetElement(lh: *mut L_HEAP, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapSort(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapSortStrictOrder(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapPrint(fp: *mut FILE, lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn jbRankHausInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        size: l_int32,
        rank: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInitWithoutComponents(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbAddPages(classer: *mut JBCLASSER, safiles: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn jbAddPage(classer: *mut JBCLASSER, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn jbAddPageComponents(
        classer: *mut JBCLASSER,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbClassifyRankHaus(classer: *mut JBCLASSER, boxa: *mut BOXA, pixas: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        area1: l_int32,
        area3: l_int32,
        rank: l_float32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyCorrelation(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbGetComponents(
        pixs: *mut PIX,
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordMaskByDilation(
        pixs: *mut PIX,
        ppixm: *mut *mut PIX,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordBoxesByDilation(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxa: *mut *mut BOXA,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbAccumulateComposites(
        pixaa: *mut PIXAA,
        pna: *mut *mut NUMA,
        pptat: *mut *mut PTA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn jbTemplatesFromComposites(pixac: *mut PIXA, na: *mut NUMA) -> *mut PIXA;
}
extern "C" {
    pub fn jbClasserCreate(method: l_int32, components: l_int32) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbClasserDestroy(pclasser: *mut *mut JBCLASSER);
}
extern "C" {
    pub fn jbDataSave(classer: *mut JBCLASSER) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataDestroy(pdata: *mut *mut JBDATA);
}
extern "C" {
    pub fn jbDataWrite(rootout: *const ::std::os::raw::c_char, jbdata: *mut JBDATA) -> l_ok;
}
extern "C" {
    pub fn jbDataRead(rootname: *const ::std::os::raw::c_char) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataRender(data: *mut JBDATA, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn jbGetULCorners(classer: *mut JBCLASSER, pixs: *mut PIX, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn jbGetLLCorners(classer: *mut JBCLASSER) -> l_ok;
}
extern "C" {
    pub fn readHeaderJp2k(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJp2k(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemJp2k(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJp2kResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadJp2k(
        filename: *const ::std::os::raw::c_char,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJp2k(
        fp: *mut FILE,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteJp2k(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJp2k(
        fp: *mut FILE,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        codec: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJp2k(
        data: *const l_uint8,
        size: size_t,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemJp2k(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadJpeg(
        filename: *const ::std::os::raw::c_char,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJpeg(
        fp: *mut FILE,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderJpeg(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJpeg(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJpegResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fgetJpegComment(fp: *mut FILE, pcomment: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn pixWriteJpeg(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJpeg(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJpeg(
        data: *const l_uint8,
        size: size_t,
        cmflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readResolutionMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemJpeg(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetChromaSampling(pix: *mut PIX, sampling: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelCreate(height: l_int32, width: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDestroy(pkel: *mut *mut L_KERNEL);
}
extern "C" {
    pub fn kernelCopy(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelGetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetElement(kel: *mut L_KERNEL, row: l_int32, col: l_int32, val: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn kernelGetParameters(
        kel: *mut L_KERNEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetOrigin(kel: *mut L_KERNEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelGetSum(kel: *mut L_KERNEL, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelGetMinMax(kel: *mut L_KERNEL, pmin: *mut l_float32, pmax: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelNormalize(kels: *mut L_KERNEL, normsum: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelInvert(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn create2dFloatArray(sy: l_int32, sx: l_int32) -> *mut *mut l_float32;
}
extern "C" {
    pub fn kernelRead(fname: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelReadStream(fp: *mut FILE) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelWrite(fname: *const ::std::os::raw::c_char, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelWriteStream(fp: *mut FILE, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelCreateFromString(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        kdata: *const ::std::os::raw::c_char,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromPix(pix: *mut PIX, cy: l_int32, cx: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDisplayInPix(kel: *mut L_KERNEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn parseStringForNumbers(
        str_: *const ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn makeFlatKernel(
        height: l_int32,
        width: l_int32,
        cy: l_int32,
        cx: l_int32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernelSep(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
        pkelx: *mut *mut L_KERNEL,
        pkely: *mut *mut L_KERNEL,
    ) -> l_ok;
}
extern "C" {
    pub fn makeDoGKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        ratio: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn getImagelibVersions() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listDestroy(phead: *mut *mut DLLIST);
}
extern "C" {
    pub fn listAddToHead(phead: *mut *mut DLLIST, data: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn listAddToTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertBefore(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertAfter(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listRemoveElement(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromHead(phead: *mut *mut DLLIST) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listFindElement(head: *mut DLLIST, data: *mut ::std::os::raw::c_void) -> *mut DLLIST;
}
extern "C" {
    pub fn listFindTail(head: *mut DLLIST) -> *mut DLLIST;
}
extern "C" {
    pub fn listGetCount(head: *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listReverse(phead: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn listJoin(phead1: *mut *mut DLLIST, phead2: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn l_amapCreate(keytype: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn l_amapFind(m: *mut L_AMAP, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_amapInsert(m: *mut L_AMAP, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_amapDelete(m: *mut L_AMAP, key: RB_TYPE);
}
extern "C" {
    pub fn l_amapDestroy(pm: *mut *mut L_AMAP);
}
extern "C" {
    pub fn l_amapGetFirst(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetNext(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetLast(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetPrev(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapSize(m: *mut L_AMAP) -> l_int32;
}
extern "C" {
    pub fn l_asetCreate(keytype: l_int32) -> *mut L_ASET;
}
extern "C" {
    pub fn l_asetFind(s: *mut L_ASET, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_asetInsert(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDelete(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDestroy(ps: *mut *mut L_ASET);
}
extern "C" {
    pub fn l_asetGetFirst(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetNext(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetLast(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetPrev(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetSize(s: *mut L_ASET) -> l_int32;
}
extern "C" {
    pub fn generateBinaryMaze(
        w: l_int32,
        h: l_int32,
        xi: l_int32,
        yi: l_int32,
        wallps: l_float32,
        ranis: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSearchBinaryMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixSearchGrayMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDilate(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixErode(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHMT(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpen(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixClose(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafe(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrick(pixd: *mut PIX, pixs: *mut PIX, hsize: l_int32, vsize: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selectComposableSels(
        size: l_int32,
        direction: l_int32,
        psel1: *mut *mut SEL,
        psel2: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selectComposableSizes(
        size: l_int32,
        pfactor1: *mut l_int32,
        pfactor2: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn resetMorphBoundaryCondition(bc: l_int32);
}
extern "C" {
    pub fn getMorphBorderPixelColor(type_: l_int32, depth: l_int32) -> l_uint32;
}
extern "C" {
    pub fn pixExtractBoundary(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceByComponent(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByComponent(
        pixas: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixMorphSequenceByRegion(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByRegion(
        pixs: *mut PIX,
        pixam: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixUnionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixIntersectionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectiveConnCompFill(
        pixs: *mut PIX,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        dsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        color: l_uint32,
        scale: l_float32,
        nlevels: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtendByMorph(
        pixas: *mut PIXA,
        type_: l_int32,
        niters: l_int32,
        sel: *mut SEL,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaExtendByScaling(
        pixas: *mut PIXA,
        nasc: *mut NUMA,
        type_: l_int32,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSeedfillMorph(
        pixs: *mut PIX,
        pixm: *mut PIX,
        maxiters: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunHistogramMorph(
        pixs: *mut PIX,
        runtype: l_int32,
        direction: l_int32,
        maxsize: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixTophat(pixs: *mut PIX, hsize: l_int32, vsize: l_int32, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixHDome(pixs: *mut PIX, height: l_int32, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFastTophat(
        pixs: *mut PIX,
        xsize: l_int32,
        ysize: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphGradient(
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
        smoothing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaCentroids(pixa: *mut PIXA) -> *mut PTA;
}
extern "C" {
    pub fn pixCentroid(
        pix: *mut PIX,
        centtab: *mut l_int32,
        sumtab: *mut l_int32,
        pxave: *mut l_float32,
        pyave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getExtendedCompositeParameters(
        size: l_int32,
        pn: *mut l_int32,
        pextra: *mut l_int32,
        pactualsize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn morphSequenceVerify(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixGrayMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaCreate(n: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromFArray(
        farray: *mut l_float32,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromString(str_: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaDestroy(pna: *mut *mut NUMA);
}
extern "C" {
    pub fn numaCopy(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaClone(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaEmpty(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaAddNumber(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaInsertNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaRemoveNumber(na: *mut NUMA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaReplaceNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetCount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSetCount(na: *mut NUMA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetFValue(na: *mut NUMA, index: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIValue(na: *mut NUMA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaSetValue(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaShiftValue(na: *mut NUMA, index: l_int32, diff: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIArray(na: *mut NUMA) -> *mut l_int32;
}
extern "C" {
    pub fn numaGetFArray(na: *mut NUMA, copyflag: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn numaGetParameters(na: *mut NUMA, pstartx: *mut l_float32, pdelx: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn numaSetParameters(na: *mut NUMA, startx: l_float32, delx: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaCopyParameters(nad: *mut NUMA, nas: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaConvertToSarray(
        na: *mut NUMA,
        size1: l_int32,
        size2: l_int32,
        addzeros: l_int32,
        type_: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn numaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadStream(fp: *mut FILE) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMA;
}
extern "C" {
    pub fn numaWriteDebug(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWrite(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStream(fp: *mut FILE, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStderr(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaCreate(n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCreateFull(nptr: l_int32, n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaTruncate(naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaDestroy(pnaa: *mut *mut NUMAA);
}
extern "C" {
    pub fn numaaAddNuma(naa: *mut NUMAA, na: *mut NUMA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaGetCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumaCount(naa: *mut NUMAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumberCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetPtrArray(naa: *mut NUMAA) -> *mut *mut NUMA;
}
extern "C" {
    pub fn numaaGetNuma(naa: *mut NUMAA, index: l_int32, accessflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaaReplaceNuma(naa: *mut NUMAA, index: l_int32, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaGetValue(
        naa: *mut NUMAA,
        i: l_int32,
        j: l_int32,
        pfval: *mut l_float32,
        pival: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaaAddNumber(naa: *mut NUMAA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadStream(fp: *mut FILE) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaWrite(filename: *const ::std::os::raw::c_char, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteStream(fp: *mut FILE, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaArithOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaLogicalOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaInvert(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimilar(
        na1: *mut NUMA,
        na2: *mut NUMA,
        maxdiff: l_float32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaAddToNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMin(na: *mut NUMA, pminval: *mut l_float32, piminloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMax(na: *mut NUMA, pmaxval: *mut l_float32, pimaxloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetSum(na: *mut NUMA, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetPartialSums(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSumOnInterval(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHasOnlyIntegers(na: *mut NUMA, pallints: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMean(na: *mut NUMA, pave: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanAbsval(na: *mut NUMA, paveabs: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaSubsample(nas: *mut NUMA, subfactor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeDelta(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeSequence(startval: l_float32, increment: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeConstant(val: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeAbsval(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        val: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSpecifiedBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRemoveBorder(nas: *mut NUMA, left: l_int32, right: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountNonzeroRuns(na: *mut NUMA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetNonzeroRange(
        na: *mut NUMA,
        eps: l_float32,
        pfirst: *mut l_int32,
        plast: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetCountRelativeToZero(na: *mut NUMA, type_: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaClipToInterval(nas: *mut NUMA, first: l_int32, last: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeThresholdIndicator(
        nas: *mut NUMA,
        thresh: l_float32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaUniformSampling(nas: *mut NUMA, nsamp: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaReverse(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaLowPassIntervals(nas: *mut NUMA, thresh: l_float32, maxn: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaThresholdEdges(
        nas: *mut NUMA,
        thresh1: l_float32,
        thresh2: l_float32,
        maxn: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSpanValues(
        na: *mut NUMA,
        span: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetEdgeValues(
        na: *mut NUMA,
        edge: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
        psign: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxVal(
        startx: l_float32,
        deltax: l_float32,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxVal(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateEqxInterval(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFitMax(
        na: *mut NUMA,
        pmaxval: *mut l_float32,
        naloc: *mut NUMA,
        pmaxloc: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDifferentiateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaIntegrateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortGeneral(
        na: *mut NUMA,
        pnasort: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        pnainvert: *mut *mut NUMA,
        sortorder: l_int32,
        sorttype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortIndexAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaChooseSortType(nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSort(naout: *mut NUMA, nain: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaBinSort(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSortIndex(na: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetBinSortIndex(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortByIndex(nas: *mut NUMA, naindex: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaIsSorted(nas: *mut NUMA, sortorder: l_int32, psorted: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSortPair(
        nax: *mut NUMA,
        nay: *mut NUMA,
        sortorder: l_int32,
        pnasx: *mut *mut NUMA,
        pnasy: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInvertMap(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSorted(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaFindSortedLoc(na: *mut NUMA, val: l_float32, pindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaPseudorandomSequence(size: l_int32, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaRandomPermutation(nas: *mut NUMA, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetRankValue(
        na: *mut NUMA,
        fract: l_float32,
        nasort: *mut NUMA,
        usebins: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMedian(na: *mut NUMA, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetBinnedMedian(na: *mut NUMA, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanDevFromMedian(na: *mut NUMA, med: l_float32, pdev: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMedianDevFromMedian(
        na: *mut NUMA,
        pmed: *mut l_float32,
        pdev: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMode(na: *mut NUMA, pval: *mut l_float32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaJoin(nad: *mut NUMA, nas: *mut NUMA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaJoin(naad: *mut NUMAA, naas: *mut NUMAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaFlattenToNuma(naa: *mut NUMAA) -> *mut NUMA;
}
extern "C" {
    pub fn numaErode(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaDilate(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaOpen(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaClose(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaTransform(nas: *mut NUMA, shift: l_float32, scale: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimpleStats(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        pmean: *mut l_float32,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedStats(
        nas: *mut NUMA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMean(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedMeanSquare(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedVariance(
        nam: *mut NUMA,
        nams: *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMedian(nas: *mut NUMA, halfwin: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToInt(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pbinsize: *mut l_int32,
        pbinstart: *mut l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramAuto(na: *mut NUMA, maxbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramClipped(
        na: *mut NUMA,
        binsize: l_float32,
        maxsize: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRebinHistogram(nas: *mut NUMA, newsize: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaNormalizeHistogram(nas: *mut NUMA, tsum: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetStatsUsingHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
        pmean: *mut l_float32,
        pvariance: *mut l_float32,
        pmedian: *mut l_float32,
        rank: l_float32,
        prval: *mut l_float32,
        phisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStats(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStatsOnInterval(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        ifirst: l_int32,
        ilast: l_int32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaMakeRankFromHistogram(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetRankFromVal(
        na: *mut NUMA,
        rval: l_float32,
        prank: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetValFromRank(
        na: *mut NUMA,
        rank: l_float32,
        prval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeSortedInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeHistoInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
        pnarank: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetRankBinValues(na: *mut NUMA, nbins: l_int32, pnam: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaGetUniformBinSizes(ntotal: l_int32, nbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSplitDistribution(
        na: *mut NUMA,
        scorefract: l_float32,
        psplitindex: *mut l_int32,
        pave1: *mut l_float32,
        pave2: *mut l_float32,
        pnum1: *mut l_float32,
        pnum2: *mut l_float32,
        pnascore: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn grayHistogramsToEMD(naa1: *mut NUMAA, naa2: *mut NUMAA, pnad: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaEarthMoverDistance(na1: *mut NUMA, na2: *mut NUMA, pdist: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn grayInterHistogramStats(
        naa: *mut NUMAA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFindPeaks(
        nas: *mut NUMA,
        nmax: l_int32,
        fract1: l_float32,
        fract2: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindExtrema(nas: *mut NUMA, delta: l_float32, pnav: *mut *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindLocForThreshold(
        na: *mut NUMA,
        skip: l_int32,
        pthresh: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCountReversals(
        nas: *mut NUMA,
        minreversal: l_float32,
        pnr: *mut l_int32,
        prd: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSelectCrossingThreshold(
        nax: *mut NUMA,
        nay: *mut NUMA,
        estthresh: l_float32,
        pbestthresh: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCrossingsByThreshold(nax: *mut NUMA, nay: *mut NUMA, thresh: l_float32)
        -> *mut NUMA;
}
extern "C" {
    pub fn numaCrossingsByPeaks(nax: *mut NUMA, nay: *mut NUMA, delta: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaEvalBestHaarParameters(
        nas: *mut NUMA,
        relweight: l_float32,
        nwidth: l_int32,
        nshift: l_int32,
        minwidth: l_float32,
        maxwidth: l_float32,
        pbestwidth: *mut l_float32,
        pbestshift: *mut l_float32,
        pbestscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaEvalHaarSum(
        nas: *mut NUMA,
        width: l_float32,
        shift: l_float32,
        relweight: l_float32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn genConstrainedNumaInRange(
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRegionsBinary(
        pixs: *mut PIX,
        ppixhm: *mut *mut PIX,
        ppixtm: *mut *mut PIX,
        ppixtb: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextlineMask(
        pixs: *mut PIX,
        ppixvws: *mut *mut PIX,
        ptlfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextblockMask(pixs: *mut PIX, pixvws: *mut PIX, pixadb: *mut PIXA) -> *mut PIX;
}
extern "C" {
    pub fn pixFindPageForeground(
        pixs: *mut PIX,
        threshold: l_int32,
        mindist: l_int32,
        erasedist: l_int32,
        showmorph: l_int32,
        pixac: *mut PIXAC,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSplitIntoCharacters(
        pixs: *mut PIX,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdebug: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitComponentWithProfile(
        pixs: *mut PIX,
        delta: l_int32,
        mindel: l_int32,
        ppixdebug: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixExtractTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        minw: l_int32,
        minh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixExtractRawTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixCountTextColumns(
        pixs: *mut PIX,
        deltafract: l_float32,
        peakfract: l_float32,
        clipfract: l_float32,
        pncols: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfText(
        pixs: *mut PIX,
        box_: *mut BOX,
        pistext: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindThreshFgExtent(
        pixs: *mut PIX,
        thresh: l_int32,
        ptop: *mut l_int32,
        pbot: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfTable(
        pixs: *mut PIX,
        box_: *mut BOX,
        orient: l_int32,
        pscore: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPrepare1bpp(
        pixs: *mut PIX,
        box_: *mut BOX,
        cropfract: l_float32,
        outres: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEstimateBackground(
        pixs: *mut PIX,
        darkthresh: l_int32,
        edgecrop: l_float32,
        pbg: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargeRectangles(
        pixs: *mut PIX,
        polarity: l_int32,
        nrect: l_int32,
        pboxa: *mut *mut BOXA,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargestRectangle(
        pixs: *mut PIX,
        polarity: l_int32,
        pbox: *mut *mut BOX,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleInCC(
        pixs: *mut PIX,
        boxs: *mut BOX,
        fract: l_float32,
        dir: l_int32,
        select: l_int32,
        debug: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixAutoPhotoinvert(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixm: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetSelectCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayRegionsCmap(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn addColorizedGrayToCmap(
        cmap: *mut PIXCMAP,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetSelectMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn parseForProtos(
        filein: *const ::std::os::raw::c_char,
        prestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn partifyFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn partifyPixac(
        pixac: *mut PIXAC,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetWhiteblocks(
        boxas: *mut BOXA,
        box_: *mut BOX,
        sortflag: l_int32,
        maxboxes: l_int32,
        maxoverlap: l_float32,
        maxperim: l_int32,
        fract: l_float32,
        maxpops: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPruneSortedOnOverlap(boxas: *mut BOXA, maxoverlap: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn convertFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdf(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdfData(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn selectDefaultPdfEncoding(pix: *mut PIX, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdf(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdfData(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledToPdfData(
        fname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdf(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdfData(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdf(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdf(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfData(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdfData(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdf(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPdf(
        fp: *mut FILE,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPdf(
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        baa: *mut BOXAA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertNumberedMasksToBoxaa(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn convertToPdfSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfDataSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfDataSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn concatenatePdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdf(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdf(pa: *mut L_PTRA, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn concatenatePdfToData(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdfToData(
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfData(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdfToData(
        pa_data: *mut L_PTRA,
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPdf(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIDataForPdf(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIData(
        fname: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateDataPdf(
        fname: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegDataMem(
        data: *mut l_uint8,
        nbytes: size_t,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateG4Data(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn pixGenerateCIData(
        pixs: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn cidConvertToPdfData(
        cid: *mut L_COMP_DATA,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_CIDataDestroy(pcid: *mut *mut L_COMP_DATA);
}
extern "C" {
    pub fn l_pdfSetG4ImageMask(flag: l_int32);
}
extern "C" {
    pub fn l_pdfSetDateAndVersion(flag: l_int32);
}
extern "C" {
    pub fn setPixMemoryManager(allocator: alloc_fn, deallocator: dealloc_fn);
}
extern "C" {
    pub fn pixCreate(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateNoInit(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplate(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplateNoInit(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateWithCmap(
        width: l_int32,
        height: l_int32,
        depth: l_int32,
        initcolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateHeader(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixClone(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDestroy(ppix: *mut *mut PIX);
}
extern "C" {
    pub fn pixCopy(pixd: *mut PIX, pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeImageData(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixCopyColormap(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixTransferAllData(
        pixd: *mut PIX,
        ppixs: *mut *mut PIX,
        copytext: l_int32,
        copyformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSwapAndDestroy(ppixd: *mut *mut PIX, ppixs: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWidth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWidth(pix: *mut PIX, width: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetHeight(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetHeight(pix: *mut PIX, height: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDepth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetDepth(pix: *mut PIX, depth: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDimensions(
        pix: *const PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetDimensions(pix: *mut PIX, w: l_int32, h: l_int32, d: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyDimensions(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetSpp(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpp(pix: *mut PIX, spp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopySpp(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWpl(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWpl(pix: *mut PIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetXRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetXRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetYRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetYRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetResolution(pix: *const PIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetResolution(pix: *mut PIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyResolution(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixScaleResolution(pix: *mut PIX, xscale: l_float32, yscale: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixGetInputFormat(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetInputFormat(pix: *mut PIX, informat: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyInputFormat(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpecial(pix: *mut PIX, special: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetText(pix: *mut PIX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixSetText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixAddText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixCopyText(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetTextCompNew(pix: *mut PIX, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn pixSetTextCompNew(pix: *mut PIX, data: *const l_uint8, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixGetColormap(pix: *mut PIX) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixSetColormap(pix: *mut PIX, colormap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixDestroyColormap(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetData(pix: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixFreeAndSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixFreeData(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixExtractData(pixs: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixGetLinePtrs(pix: *mut PIX, psize: *mut l_int32) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixSizesEqual(pix1: *const PIX, pix2: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixMaxAspectRatio(pixs: *mut PIX, pratio: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixPrintStreamInfo(
        fp: *mut FILE,
        pix: *const PIX,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixel(pix: *mut PIX, x: l_int32, y: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetPixel(pix: *mut PIX, x: l_int32, y: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetCmapPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRandomPixel(
        pix: *mut PIX,
        pval: *mut l_uint32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClearPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFlipPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn setPixelLow(line: *mut l_uint32, x: l_int32, depth: l_int32, val: l_uint32);
}
extern "C" {
    pub fn pixGetBlackOrWhiteVal(pixs: *mut PIX, op: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixClearAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAllGray(pix: *mut PIX, grayval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetAllArbitrary(pix: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetBlackOrWhite(pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetComponentArbitrary(pix: *mut PIX, comp: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClearInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRectArbitrary(pix: *mut PIX, box_: *mut BOX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixBlendInRect(pixs: *mut PIX, box_: *mut BOX, val: l_uint32, fract: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBits(pix: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBitsBand(pix: *mut PIX, by: l_int32, bh: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetOrClearBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderVal(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderRingVal(pixs: *mut PIX, dist: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyBorder(
        pixd: *mut PIX,
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorder(pixs: *mut PIX, npix: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBlackOrWhiteBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMultipleBlackWhiteBorders(
        pixs: *mut PIX,
        nblack1: l_int32,
        nwhite1: l_int32,
        nblack2: l_int32,
        nwhite2: l_int32,
        nblack3: l_int32,
        nwhite3: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorder(pixs: *mut PIX, npix: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRepeatedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMixedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddContinuedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixShiftAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        shiftx: l_float32,
        shifty: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayLayersRGBA(pixs: *mut PIX, val: l_uint32, maxw: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateRGBImage(pixr: *mut PIX, pixg: *mut PIX, pixb: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBComponent(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBComponentCmap(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCopyRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn composeRGBPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn composeRGBAPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn extractRGBValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractRGBAValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractMinMaxComponent(pixel: l_uint32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBLine(
        pixs: *mut PIX,
        row: l_int32,
        bufr: *mut l_uint8,
        bufg: *mut l_uint8,
        bufb: *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn setLineDataVal(line: *mut l_uint32, j: l_int32, d: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixEndianByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn lineEndianByteSwap(datad: *mut l_uint32, datas: *mut l_uint32, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEndianTwoByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianTwoByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRasterData(pixs: *mut PIX, pdata: *mut *mut l_uint8, pnbytes: *mut size_t)
        -> l_ok;
}
extern "C" {
    pub fn pixInferResolution(pix: *mut PIX, longside: l_float32, pres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixAlphaIsOpaque(pix: *mut PIX, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetupByteProcessing(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut *mut l_uint8;
}
extern "C" {
    pub fn pixCleanupByteProcessing(pix: *mut PIX, lineptrs: *mut *mut l_uint8) -> l_ok;
}
extern "C" {
    pub fn l_setAlphaMaskBorder(val1: l_float32, val2: l_float32);
}
extern "C" {
    pub fn pixSetMasked(pixd: *mut PIX, pixm: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedGeneral(
        pixd: *mut PIX,
        pixm: *mut PIX,
        val: l_uint32,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCombineMasked(pixd: *mut PIX, pixs: *mut PIX, pixm: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixCombineMaskedGeneral(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPaintThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyWithBoxa(pixs: *mut PIX, boxa: *mut BOXA, background: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintSelfThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        searchdir: l_int32,
        mindist: l_int32,
        tilesize: l_int32,
        ntiles: l_int32,
        distblend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeMaskFromVal(pixs: *mut PIX, val: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeMaskFromLUT(pixs: *mut PIX, tab: *mut l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeArbMaskFromRGB(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetUnderTransparency(pixs: *mut PIX, val: l_uint32, debug: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeAlphaFromMask(pixs: *mut PIX, dist: l_int32, pbox: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetColorNearMaskBoundary(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pval: *mut l_uint32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplaySelectedPixels(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sel: *mut SEL,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInvert(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixOr(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAnd(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixXor(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtract(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixZero(pix: *mut PIX, pempty: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixForegroundFraction(pix: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaCountPixels(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixels(pixs: *mut PIX, pcount: *mut l_int32, tab8: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountPixelsInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByRow(pix: *mut PIX, tab8: *mut l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByColumn(pix: *mut PIX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsInRow(
        pix: *mut PIX,
        row: l_int32,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMomentByColumn(pix: *mut PIX, order: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixThresholdPixelSum(
        pix: *mut PIX,
        thresh: l_int32,
        pabove: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePixelSumTab8() -> *mut l_int32;
}
extern "C" {
    pub fn makePixelCentroidTab8() -> *mut l_int32;
}
extern "C" {
    pub fn pixAverageByRow(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageByColumn(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageInRect(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        minval: l_int32,
        maxval: l_int32,
        subsamp: l_int32,
        pave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAverageInRectRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        subsamp: l_int32,
        pave: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceInRect(pix: *mut PIX, box_: *mut BOX, prootvar: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffInRect(
        pix: *mut PIX,
        box_: *mut BOX,
        dir: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffOnLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountArbInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_int32,
        factor: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirroredTiling(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindRepCloseTile(
        pixs: *mut PIX,
        box_: *mut BOX,
        searchdir: l_int32,
        mindist: l_int32,
        tsize: l_int32,
        ntiles: l_int32,
        pboxtile: *mut *mut BOX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetGrayHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramTiled(
        pixs: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixGetColorHistogram(
        pixs: *mut PIX,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColorHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetCmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountRGBColorsByHash(pixs: *mut PIX, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountRGBColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetColorAmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn amapGetCountForColor(amap: *mut L_AMAP, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValue(
        pixs: *mut PIX,
        factor: l_int32,
        rank: l_float32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        pval: *mut l_float32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelAverage(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelStats(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiledRGB(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiled(pixs: *mut PIX, sx: l_int32, sy: l_int32, type_: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixRowStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColumnStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRangeValues(
        pixs: *mut PIX,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetExtremeValue(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        pgrayval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxValueInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pmaxval: *mut l_uint32,
        pxmax: *mut l_int32,
        pymax: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxColorIndex(pixs: *mut PIX, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedComponentRange(
        pixs: *mut PIX,
        nbins: l_int32,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pcarray: *mut *mut l_uint32,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankColorArray(
        pixs: *mut PIX,
        nbins: l_int32,
        type_: l_int32,
        factor: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedColor(
        pixs: *mut PIX,
        pixg: *mut PIX,
        factor: l_int32,
        nbins: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayColorArray(
        carray: *mut l_uint32,
        ncolors: l_int32,
        side: l_int32,
        ncols: l_int32,
        fontsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRankBinByStrip(
        pixs: *mut PIX,
        direction: l_int32,
        size: l_int32,
        nbins: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetAlignedStats(
        pixa: *mut PIXA,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtractColumnFromEachPix(pixa: *mut PIXA, col: l_int32, pixd: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRowStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        colvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColumnStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        rowvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetPixelColumn(pix: *mut PIX, col: l_int32, colvect: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixThresholdForFgBg(
        pixs: *mut PIX,
        factor: l_int32,
        thresh: l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitDistributionFgBg(
        pixs: *mut PIX,
        scorefract: l_float32,
        factor: l_int32,
        pthresh: *mut l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindDimensions(pixa: *mut PIXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixFindAreaPerimRatio(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimToAreaRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimToAreaRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimSizeRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimSizeRatio(pixs: *mut PIX, tab: *mut l_int32, pratio: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFraction(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFraction(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFractionMasked(pixa: *mut PIXA, pixm: *mut PIX, debug: l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFractionMasked(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixm: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindWidthHeightRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixaFindWidthHeightProduct(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindOverlapFraction(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x2: l_int32,
        y2: l_int32,
        tab: *mut l_int32,
        pratio: *mut l_float32,
        pnoverlap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleComps(
        pixs: *mut PIX,
        dist: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConformsToRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pconforms: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipRectangles(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixClipRectangle(pixs: *mut PIX, box_: *mut BOX, pboxc: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixClipRectangleWithBorder(
        pixs: *mut PIX,
        box_: *mut BOX,
        maxbord: l_int32,
        pboxn: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixClipMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        outval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCropToMatch(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        ppixd1: *mut *mut PIX,
        ppixd2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropToSize(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeToMatch(pixs: *mut PIX, pixt: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFilterComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeSymmetricMask(
        w: l_int32,
        h: l_int32,
        hf: l_float32,
        vf: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeFrameMask(
        w: l_int32,
        h: l_int32,
        hf1: l_float32,
        hf2: l_float32,
        vf1: l_float32,
        vf2: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeCoveringOfRectangles(pixs: *mut PIX, maxiters: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFractionFgInMask(pix1: *mut PIX, pix2: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixClipToForeground(pixs: *mut PIX, ppixd: *mut *mut PIX, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixTestClipToForeground(pixs: *mut PIX, pcanclip: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToForeground(
        pixs: *mut PIX,
        boxs: *mut BOX,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForForeground(
        pixs: *mut PIX,
        box_: *mut BOX,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToEdges(
        pixs: *mut PIX,
        boxs: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForEdge(
        pixs: *mut PIX,
        box_: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExtractOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> l_float32;
}
extern "C" {
    pub fn pixAverageIntensityProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixReversalProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        minreversal: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixWindowedVarianceOnLine(
        pixs: *mut PIX,
        dir: l_int32,
        loc: l_int32,
        c1: l_int32,
        c2: l_int32,
        size: l_int32,
        pnad: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMinMaxNearLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        dist: l_int32,
        direction: l_int32,
        pnamin: *mut *mut NUMA,
        pnamax: *mut *mut NUMA,
        pminave: *mut l_float32,
        pmaxave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRankRowTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRankColumnTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixaCreate(n: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromPix(
        pixs: *mut PIX,
        n: l_int32,
        cellw: l_int32,
        cellh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromBoxa(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        start: l_int32,
        num: l_int32,
        pcropwarn: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitPix(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaDestroy(ppixa: *mut *mut PIXA);
}
extern "C" {
    pub fn pixaCopy(pixa: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPix(pixa: *mut PIXA, pix: *mut PIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAddBox(pixa: *mut PIXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaExtendArrayToSize(pixa: *mut PIXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixaGetCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetPix(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetPixDimensions(
        pixa: *mut PIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetBoxa(pixa: *mut PIXA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaGetBoxaCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetBox(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixaGetBoxGeometry(
        pixa: *mut PIXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetBoxa(pixa: *mut PIXA, boxa: *mut BOXA, accesstype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPixArray(pixa: *mut PIXA) -> *mut *mut PIX;
}
extern "C" {
    pub fn pixaVerifyDepth(pixa: *mut PIXA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaVerifyDimensions(
        pixa: *mut PIXA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaIsFull(pixa: *mut PIXA, pfullpa: *mut l_int32, pfullba: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCountText(pixa: *mut PIXA, pntext: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaSetText(
        pixa: *mut PIXA,
        text: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetLinePtrs(
        pixa: *mut PIXA,
        psize: *mut l_int32,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixaWriteStreamInfo(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReplacePix(pixa: *mut PIXA, index: l_int32, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaInsertPix(pixa: *mut PIXA, index: l_int32, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePix(pixa: *mut PIXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePixAndSave(
        pixa: *mut PIXA,
        index: l_int32,
        ppix: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveSelected(pixa: *mut PIXA, naindex: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaInitFull(pixa: *mut PIXA, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaClear(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaJoin(pixad: *mut PIXA, pixas: *mut PIXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaInterleave(pixa1: *mut PIXA, pixa2: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaJoin(paad: *mut PIXAA, paas: *mut PIXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaCreate(n: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaCreateFromPixa(
        pixa: *mut PIXA,
        n: l_int32,
        type_: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaDestroy(ppaa: *mut *mut PIXAA);
}
extern "C" {
    pub fn pixaaAddPixa(paa: *mut PIXAA, pixa: *mut PIXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaAddPix(
        paa: *mut PIXAA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaAddBox(paa: *mut PIXAA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaGetCount(paa: *mut PIXAA, pna: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaaGetPixa(paa: *mut PIXAA, index: l_int32, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaGetBoxa(paa: *mut PIXAA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaaGetPix(
        paa: *mut PIXAA,
        index: l_int32,
        ipix: l_int32,
        accessflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaVerifyDepth(paa: *mut PIXAA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaVerifyDimensions(
        paa: *mut PIXAA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaIsFull(paa: *mut PIXAA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaInitFull(paa: *mut PIXAA, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaReplacePixa(paa: *mut PIXAA, index: l_int32, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaClear(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaTruncate(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadStream(fp: *mut FILE) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteDebug(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWrite(filename: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStream(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReadBoth(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadStream(fp: *mut FILE) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaWrite(filename: *const ::std::os::raw::c_char, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteStream(fp: *mut FILE, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaccCreate(w: l_int32, h: l_int32, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccCreateFromPix(pix: *mut PIX, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccDestroy(ppixacc: *mut *mut PIXACC);
}
extern "C" {
    pub fn pixaccFinal(pixacc: *mut PIXACC, outdepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetPix(pixacc: *mut PIXACC) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetOffset(pixacc: *mut PIXACC) -> l_int32;
}
extern "C" {
    pub fn pixaccAdd(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccSubtract(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConst(pixacc: *mut PIXACC, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConstAccumulate(pixacc: *mut PIXACC, pix: *mut PIX, factor: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixSelectBySize(
        pixs: *mut PIX,
        width: l_int32,
        height: l_int32,
        connectivity: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectBySize(
        pixas: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeSizeIndicator(
        pixa: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSelectByPerimToAreaRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimToAreaRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByPerimSizeRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimSizeRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByAreaFraction(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByAreaFraction(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByArea(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByArea(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByWidthHeightRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByWidthHeightRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectByNumConnComp(
        pixas: *mut PIXA,
        nmin: l_int32,
        nmax: l_int32,
        connectivity: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectWithIndicator(
        pixas: *mut PIXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixRemoveWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixAddWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaSelectWithString(
        pixas: *mut PIXA,
        str_: *const ::std::os::raw::c_char,
        perror: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRenderComponent(pixs: *mut PIX, pixa: *mut PIXA, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaBinSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSortByIndex(pixas: *mut PIXA, naindex: *mut NUMA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSort2dByIndex(pixas: *mut PIXA, naa: *mut NUMAA, copyflag: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaSelectRange(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSelectRange(
        paas: *mut PIXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSize(paas: *mut PIXAA, wd: l_int32, hd: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSizeVar(paas: *mut PIXAA, nawd: *mut NUMA, nahd: *mut NUMA) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaScaleToSize(pixas: *mut PIXA, wd: l_int32, hd: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleToSizeRel(pixas: *mut PIXA, delw: l_int32, delh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScale(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleBySampling(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32)
        -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotate(
        pixas: *mut PIXA,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotateOrth(pixas: *mut PIXA, rotation: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaTranslate(
        pixas: *mut PIXA,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddBorderGeneral(
        pixad: *mut PIXA,
        pixas: *mut PIXA,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaFlattenToPixa(
        paa: *mut PIXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSizeRange(
        paa: *mut PIXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSizeRange(
        pixa: *mut PIXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaClipToPix(pixas: *mut PIXA, pixs: *mut PIX) -> *mut PIXA;
}
extern "C" {
    pub fn pixaClipToForeground(
        pixas: *mut PIXA,
        ppixad: *mut *mut PIXA,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetRenderingDepth(pixa: *mut PIXA, pdepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaHasColor(pixa: *mut PIXA, phascolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAnyColormaps(pixa: *mut PIXA, phascmap: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetDepthInfo(pixa: *mut PIXA, pmaxdepth: *mut l_int32, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToSameDepth(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToGivenDepth(pixas: *mut PIXA, depth: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaEqual(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetFullSizeBoxa(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaDisplay(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayRandomCmap(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayLinearly(
        pixas: *mut PIXA,
        direction: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnLattice(
        pixa: *mut PIXA,
        cellw: l_int32,
        cellh: l_int32,
        pncols: *mut l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayUnsplit(
        pixa: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiled(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        background: l_int32,
        spacing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInRows(
        pixa: *mut PIXA,
        outdepth: l_int32,
        maxwidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInColumns(
        pixas: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledAndScaled(
        pixa: *mut PIXA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledWithText(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledByIndex(
        pixa: *mut PIXA,
        na: *mut NUMA,
        width: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayPairTiledInColumns(
        pixas1: *mut PIXA,
        pixas2: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing1: l_int32,
        spacing2: l_int32,
        border1: l_int32,
        border2: l_int32,
        fontsize: l_int32,
        startindex: l_int32,
        sa: *mut SARRAY,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplay(paa: *mut PIXAA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayByPixa(
        paa: *mut PIXAA,
        maxnx: l_int32,
        scalefactor: l_float32,
        hspacing: l_int32,
        vspacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayTiledAndScaled(
        paa: *mut PIXAA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo1(pixas: *mut PIXA, thresh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8(pixas: *mut PIXA, cmapflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8Colormap(pixas: *mut PIXA, dither: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo32(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConstrainedSelect(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectToPdf(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        color: l_uint32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaMakeFromTiledPixa(
        pixas: *mut PIXA,
        w: l_int32,
        h: l_int32,
        nsamp: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeFromTiledPix(
        pixs: *mut PIX,
        w: l_int32,
        h: l_int32,
        start: l_int32,
        num: l_int32,
        boxa: *mut BOXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixGetTileCount(pix: *mut PIX, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaDisplayMultiTiled(
        pixas: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        maxw: l_int32,
        maxh: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitIntoFiles(
        pixas: *mut PIXA,
        nsplit: l_int32,
        scale: l_float32,
        outwidth: l_int32,
        write_pixa: l_int32,
        write_pix: l_int32,
        write_pdf: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpFiles(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpPixa(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToNUpPixa(
        pixas: *mut PIXA,
        sa: *mut SARRAY,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCompareInPdf(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsCreate(
        minsize: size_t,
        smallest: size_t,
        numalloc: *mut NUMA,
        logfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsDestroy();
}
extern "C" {
    pub fn pmsCustomAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsCustomDealloc(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pmsGetAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsGetLevelForAlloc(nbytes: size_t, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsGetLevelForDealloc(data: *mut ::std::os::raw::c_void, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsLogInfo();
}
extern "C" {
    pub fn pixAddConstantGray(pixs: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstantGray(pixs: *mut PIX, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAddGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtractGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyGray(pixs: *mut PIX, pixg: *mut PIX, norm: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToValue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        threshval: l_int32,
        setval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInitAccumulate(w: l_int32, h: l_int32, offset: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulate(pixs: *mut PIX, offset: l_uint32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulateThreshold(
        pixs: *mut PIX,
        offset: l_uint32,
        threshold: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAccumulate(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstAccumulate(pixs: *mut PIX, factor: l_float32, offset: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDifference(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRGB(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMinOrMax(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRange(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRangeRGB(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn linearScaleRGBVal(sval: l_uint32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn logScaleRGBVal(sval: l_uint32, tab: *mut l_float32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn makeLogBase2Tab() -> *mut l_float32;
}
extern "C" {
    pub fn getLogBase2(val: l_int32, logtab: *mut l_float32) -> l_float32;
}
extern "C" {
    pub fn pixcompCreateFromPix(pix: *mut PIX, comptype: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromString(
        data: *mut l_uint8,
        size: size_t,
        copyflag: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompDestroy(ppixc: *mut *mut PIXC);
}
extern "C" {
    pub fn pixcompCopy(pixcs: *mut PIXC) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompGetDimensions(
        pixc: *mut PIXC,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompGetParameters(
        pixc: *mut PIXC,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
        pcomptype: *mut l_int32,
        pcmapflag: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompDetermineFormat(
        comptype: l_int32,
        d: l_int32,
        cmapflag: l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCreateFromPixcomp(pixc: *mut PIXC) -> *mut PIX;
}
extern "C" {
    pub fn pixacompCreate(n: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateWithInit(
        n: l_int32,
        offset: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromPixa(
        pixa: *mut PIXA,
        comptype: l_int32,
        accesstype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromSA(sa: *mut SARRAY, comptype: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompDestroy(ppixac: *mut *mut PIXAC);
}
extern "C" {
    pub fn pixacompAddPix(pixac: *mut PIXAC, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompAddPixcomp(pixac: *mut PIXAC, pixc: *mut PIXC, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePix(
        pixac: *mut PIXAC,
        index: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePixcomp(pixac: *mut PIXAC, index: l_int32, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixacompAddBox(pixac: *mut PIXAC, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompGetCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetPixcomp(pixac: *mut PIXAC, index: l_int32, copyflag: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixacompGetPix(pixac: *mut PIXAC, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixacompGetPixDimensions(
        pixac: *mut PIXAC,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetBoxa(pixac: *mut PIXAC, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixacompGetBoxaCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBox(pixac: *mut PIXAC, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixacompGetBoxGeometry(
        pixac: *mut PIXAC,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetOffset(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompSetOffset(pixac: *mut PIXAC, offset: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCreateFromPixacomp(pixac: *mut PIXAC, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixacompJoin(
        pixacd: *mut PIXAC,
        pixacs: *mut PIXAC,
        istart: l_int32,
        iend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompInterleave(pixac1: *mut PIXAC, pixac2: *mut PIXAC) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadStream(fp: *mut FILE) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompWrite(filename: *const ::std::os::raw::c_char, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStream(fp: *mut FILE, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixac: *mut PIXAC,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdf(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdfData(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompFastConvertToPdfData(
        pixac: *mut PIXAC,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStreamInfo(
        fp: *mut FILE,
        pixac: *mut PIXAC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteStreamInfo(
        fp: *mut FILE,
        pixc: *mut PIXC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompDisplayTiledAndScaled(
        pixac: *mut PIXAC,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixacompWriteFiles(pixac: *mut PIXAC, subdir: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteFile(rootname: *const ::std::os::raw::c_char, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixThreshold8(
        pixs: *mut PIX,
        d: l_int32,
        nlevels: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormapGeneral(pixs: *mut PIX, type_: l_int32, ifnocmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormap(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddGrayColormap8(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixAddMinimalGrayColormap8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToLuminance(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayGeneral(
        pixs: *mut PIX,
        type_: l_int32,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGray(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayFast(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayMinMax(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGraySatBoost(pixs: *mut PIX, refval: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToBinaryArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_int32,
        relation: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap8(pixs: *mut PIX, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixColorizeGray(pixs: *mut PIX, color: l_uint32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToColormap(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertCmapTo1(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantizeIfFewColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        mingraycolors: l_int32,
        octlevel: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvert16To8(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToFalseColor(pixs: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnpackBinary(pixs: *mut PIX, depth: l_int32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To16(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint16,
        val1: l_uint16,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To32(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint32,
        val1: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8(pixd: *mut PIX, pixs: *mut PIX, val0: l_uint8, val1: l_uint8)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert2To8(
        pixs: *mut PIX,
        val0: l_uint8,
        val1: l_uint8,
        val2: l_uint8,
        val3: l_uint8,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert4To8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To16(pixs: *mut PIX, leftshift: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To4(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1Adaptive(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1(pixs: *mut PIX, threshold: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1BySampling(pixs: *mut PIX, factor: l_int32, threshold: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8BySampling(pixs: *mut PIX, factor: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Colormap(pixs: *mut PIX, dither: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32BySampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Or32(pixs: *mut PIX, copyflag: l_int32, warnflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert24To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To24(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To16(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To8(pixs: *mut PIX, type16: l_int32, type8: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveAlpha(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaTo1bpp(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertLossless(pixs: *mut PIX, d: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertForPSWrap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertColorToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setNeutralBoostVal(val: l_int32);
}
extern "C" {
    pub fn pixConnCompTransform(pixs: *mut PIX, connect: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompAreaTransform(pixs: *mut PIX, connect: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompIncrInit(
        pixs: *mut PIX,
        conn: l_int32,
        ppixd: *mut *mut PIX,
        pptaa: *mut *mut PTAA,
        pncc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnCompIncrAdd(
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pncc: *mut l_int32,
        x: l_float32,
        y: l_float32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetSortedNeighborValues(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        conn: l_int32,
        pneigh: *mut *mut l_int32,
        pnvals: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixLocToColorTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingCreate(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        w: l_int32,
        h: l_int32,
        xoverlap: l_int32,
        yoverlap: l_int32,
    ) -> *mut PIXTILING;
}
extern "C" {
    pub fn pixTilingDestroy(ppt: *mut *mut PIXTILING);
}
extern "C" {
    pub fn pixTilingGetCount(pt: *mut PIXTILING, pnx: *mut l_int32, pny: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetSize(pt: *mut PIXTILING, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetTile(pt: *mut PIXTILING, i: l_int32, j: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingNoStripOnPaint(pt: *mut PIXTILING) -> l_ok;
}
extern "C" {
    pub fn pixTilingPaintTile(
        pixd: *mut PIX,
        i: l_int32,
        j: l_int32,
        pixs: *mut PIX,
        pt: *mut PIXTILING,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPng(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPng(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPng(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemPng(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn isPngInterlaced(
        filename: *const ::std::os::raw::c_char,
        pinterlaced: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngColormapInfo(
        fp: *mut FILE,
        pcmap: *mut *mut PIXCMAP,
        ptransparency: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePng(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPng(fp: *mut FILE, pix: *mut PIX, gamma: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetZlibCompression(pix: *mut PIX, compval: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_pngSetReadStrip16To8(flag: l_int32);
}
extern "C" {
    pub fn pixReadMemPng(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemPng(
        pfiledata: *mut *mut l_uint8,
        pfilesize: *mut size_t,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPnm(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPnm(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPnm(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamAsciiPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPam(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemPnm(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemPnm(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPnm(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPam(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixProjectiveSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjective(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getProjectiveXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesToPS(
        sa: *mut SARRAY,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesFittedToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesFittedToPS(
        sa: *mut SARRAY,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageCompressedToPSFile(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedPagesToPS(
        pagedir: *const ::std::os::raw::c_char,
        pagestr: *const ::std::os::raw::c_char,
        page_numpre: l_int32,
        maskdir: *const ::std::os::raw::c_char,
        maskstr: *const ::std::os::raw::c_char,
        mask_numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteSegmentedPageToPS(
        pixs: *mut PIX,
        pixm: *mut PIX,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMixedToPS(
        pixb: *mut PIX,
        pixc: *mut PIX,
        scale: l_float32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteCompressedToPS(
        pixa: *mut PIXA,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteCompressedToPS(
        pix: *mut PIX,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPS(
        fp: *mut FILE,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStringPS(
        pixs: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generateUncompressedPS(
        hexdata: *mut ::std::os::raw::c_char,
        w: l_int32,
        h: l_int32,
        d: l_int32,
        psbpl: l_int32,
        bps: l_int32,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        boxflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertJpegToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertJpegToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        fillfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPS(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn getResLetterPage(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn getResA4Page(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_psWriteBoundingBox(flag: l_int32);
}
extern "C" {
    pub fn ptaCreate(n: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaCreateFromNuma(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaDestroy(ppta: *mut *mut PTA);
}
extern "C" {
    pub fn ptaCopy(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCopyRange(ptas: *mut PTA, istart: l_int32, iend: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaClone(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEmpty(pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaAddPt(pta: *mut PTA, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaInsertPt(pta: *mut PTA, index: l_int32, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaRemovePt(pta: *mut PTA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaGetCount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaGetPt(pta: *mut PTA, index: l_int32, px: *mut l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetIPt(pta: *mut PTA, index: l_int32, px: *mut l_int32, py: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaSetPt(pta: *mut PTA, index: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetArrays(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn ptaRead(filename: *const ::std::os::raw::c_char) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadStream(fp: *mut FILE) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadMem(data: *const l_uint8, size: size_t) -> *mut PTA;
}
extern "C" {
    pub fn ptaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaWrite(filename: *const ::std::os::raw::c_char, pta: *mut PTA, type_: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn ptaWriteStream(fp: *mut FILE, pta: *mut PTA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaCreate(n: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaDestroy(pptaa: *mut *mut PTAA);
}
extern "C" {
    pub fn ptaaAddPta(ptaa: *mut PTAA, pta: *mut PTA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaGetCount(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaGetPta(ptaa: *mut PTAA, index: l_int32, accessflag: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetPt(
        ptaa: *mut PTAA,
        ipta: l_int32,
        jpt: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaInitFull(ptaa: *mut PTAA, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaReplacePta(ptaa: *mut PTAA, index: l_int32, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaAddPt(ptaa: *mut PTAA, ipta: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaaTruncate(ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn ptaaRead(filename: *const ::std::os::raw::c_char) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadStream(fp: *mut FILE) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadMem(data: *const l_uint8, size: size_t) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWrite(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteStream(fp: *mut FILE, ptaa: *mut PTAA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSubsample(ptas: *mut PTA, subfactor: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaJoin(ptad: *mut PTA, ptas: *mut PTA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaJoin(ptaad: *mut PTAA, ptaas: *mut PTAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaReverse(ptas: *mut PTA, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaTranspose(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCyclicPerm(ptas: *mut PTA, xs: l_int32, ys: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaSelectRange(ptas: *mut PTA, first: l_int32, last: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetBoundingRegion(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn ptaGetRange(
        pta: *mut PTA,
        pminx: *mut l_float32,
        pmaxx: *mut l_float32,
        pminy: *mut l_float32,
        pmaxy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetInsideBox(ptas: *mut PTA, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixFindCornerPixels(pixs: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaContainsPt(pta: *mut PTA, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaTestIntersection(pta1: *mut PTA, pta2: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaTransform(
        ptas: *mut PTA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaPtInsidePolygon(
        pta: *mut PTA,
        x: l_float32,
        y: l_float32,
        pinside: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_angleBetweenVectors(
        x1: l_float32,
        y1: l_float32,
        x2: l_float32,
        y2: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn ptaPolygonIsConvex(pta: *mut PTA, pisconvex: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetMinMax(
        pta: *mut PTA,
        pxmin: *mut l_float32,
        pymin: *mut l_float32,
        pxmax: *mut l_float32,
        pymax: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSelectByValue(
        ptas: *mut PTA,
        xth: l_float32,
        yth: l_float32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaCropToMask(ptas: *mut PTA, pixm: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetLinearLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuadraticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetCubicLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuarticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pe: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyLinearLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyQuadraticLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn applyLinearFit(a: l_float32, b: l_float32, x: l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn applyQuadraticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyCubicFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyQuarticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        e: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPlotAlongPta(
        pixs: *mut PIX,
        pta: *mut PTA,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetPixelsFromPix(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGenerateFromPta(pta: *mut PTA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn ptaGetBoundaryPixels(pixs: *mut PIX, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetBoundaryPixels(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaIndexLabeledPixels(pixs: *mut PIX, pncc: *mut l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetNeighborPixLocs(pixs: *mut PIX, x: l_int32, y: l_int32, conn: l_int32)
        -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta1(na: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta2(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToNuma(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixDisplayPta(pixd: *mut PIX, pixs: *mut PIX, pta: *mut PTA) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pta: *mut PTA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ptaReplicatePattern(
        ptas: *mut PTA,
        pixp: *mut PIX,
        ptap: *mut PTA,
        cx: l_int32,
        cy: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDisplayPtaa(pixs: *mut PIX, ptaa: *mut PTAA) -> *mut PIX;
}
extern "C" {
    pub fn ptaSort(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetSortIndex(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSortByIndex(ptas: *mut PTA, naindex: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaaSortByIndex(ptaas: *mut PTAA, naindex: *mut NUMA) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetRankValue(
        pta: *mut PTA,
        fract: l_float32,
        ptasort: *mut PTA,
        sorttype: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSort2d(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEqual(pta1: *mut PTA, pta2: *mut PTA, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_asetCreateFromPta(pta: *mut PTA) -> *mut L_ASET;
}
extern "C" {
    pub fn ptaRemoveDupsByAset(ptas: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromPta(pta: *mut PTA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn ptaRemoveDupsByHmap(
        ptas: *mut PTA,
        pptad: *mut *mut PTA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptraCreate(n: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraDestroy(ppa: *mut *mut L_PTRA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraAdd(pa: *mut L_PTRA, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn ptraInsert(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        shiftflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraRemove(
        pa: *mut L_PTRA,
        index: l_int32,
        flag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraRemoveLast(pa: *mut L_PTRA) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraReplace(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        freeflag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraSwap(pa: *mut L_PTRA, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraCompactArray(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraReverse(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraJoin(pa1: *mut L_PTRA, pa2: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraGetMaxIndex(pa: *mut L_PTRA, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetActualCount(pa: *mut L_PTRA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetPtrToItem(pa: *mut L_PTRA, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraaCreate(n: l_int32) -> *mut L_PTRAA;
}
extern "C" {
    pub fn ptraaDestroy(ppaa: *mut *mut L_PTRAA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraaGetSize(paa: *mut L_PTRAA, psize: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraaInsertPtra(paa: *mut L_PTRAA, index: l_int32, pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraaGetPtra(paa: *mut L_PTRAA, index: l_int32, accessflag: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraaFlattenToPtra(paa: *mut L_PTRAA) -> *mut L_PTRA;
}
extern "C" {
    pub fn pixQuadtreeMean(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        pfpixa: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixQuadtreeVariance(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pfpixa_v: *mut *mut FPIXA,
        pfpixa_rv: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixma: *mut PIX,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaQuadtreeRegions(w: l_int32, h: l_int32, nlevels: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn quadtreeGetParent(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeGetChildren(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval00: *mut l_float32,
        pval10: *mut l_float32,
        pval01: *mut l_float32,
        pval11: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeMaxLevels(w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaDisplayQuadtree(fpixa: *mut FPIXA, factor: l_int32, fontsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lqueueCreate(nalloc: l_int32) -> *mut L_QUEUE;
}
extern "C" {
    pub fn lqueueDestroy(plq: *mut *mut L_QUEUE, freeflag: l_int32);
}
extern "C" {
    pub fn lqueueAdd(lq: *mut L_QUEUE, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lqueueRemove(lq: *mut L_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lqueueGetCount(lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn lqueuePrint(fp: *mut FILE, lq: *mut L_QUEUE) -> l_ok;
}
extern "C" {
    pub fn pixRankFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterRGB(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterGray(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixMedianFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterWithScaling(
        pixs: *mut PIX,
        wf: l_int32,
        hf: l_int32,
        rank: l_float32,
        scalefactor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_rbtreeCreate(keytype: l_int32) -> *mut L_RBTREE;
}
extern "C" {
    pub fn l_rbtreeLookup(t: *mut L_RBTREE, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_rbtreeInsert(t: *mut L_RBTREE, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDelete(t: *mut L_RBTREE, key: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDestroy(pt: *mut *mut L_RBTREE);
}
extern "C" {
    pub fn l_rbtreeGetFirst(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetNext(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetLast(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetPrev(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetCount(t: *mut L_RBTREE) -> l_int32;
}
extern "C" {
    pub fn l_rbtreePrint(fp: *mut FILE, t: *mut L_RBTREE);
}
extern "C" {
    pub fn pixProcessBarcodes(
        pixs: *mut PIX,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixExtractBarcodes(pixs: *mut PIX, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixReadBarcodes(
        pixa: *mut PIXA,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadBarcodeWidths(pixs: *mut PIX, method: l_int32, debugflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixLocateBarcodes(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixb: *mut *mut PIX,
        ppixm: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixDeskewBarcode(
        pixs: *mut PIX,
        pixb: *mut PIX,
        box_: *mut BOX,
        margin: l_int32,
        threshold: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBarcodeWidths1(
        pixs: *mut PIX,
        thresh: l_float32,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeWidths2(
        pixs: *mut PIX,
        thresh: l_float32,
        pwidth: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeCrossings(
        pixs: *mut PIX,
        thresh: l_float32,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWidth(
        nas: *mut NUMA,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWindow(
        nas: *mut NUMA,
        ratio: l_float32,
        pwidth: *mut l_float32,
        pfirstloc: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaReadFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadFilesSA(sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn pixRead(filename: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn pixReadWithHint(filename: *const ::std::os::raw::c_char, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadIndexed(sa: *mut SARRAY, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStream(fp: *mut FILE, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeader(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findFileFormat(filename: *const ::std::os::raw::c_char, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatStream(fp: *mut FILE, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatBuffer(buf: *const l_uint8, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fileFormatIsTiff(fp: *mut FILE) -> l_int32;
}
extern "C" {
    pub fn pixReadMem(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeaderMem(
        data: *const l_uint8,
        size: size_t,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageFileInfo(
        filename: *const ::std::os::raw::c_char,
        fpout: *mut FILE,
        headeronly: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ioFormatTest(filename: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn recogCreateFromRecog(
        recs: *mut L_RECOG,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixa(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixaNoFinish(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreate(
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogDestroy(precog: *mut *mut L_RECOG);
}
extern "C" {
    pub fn recogGetCount(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogSetParams(
        recog: *mut L_RECOG,
        type_: l_int32,
        min_nopad: l_int32,
        max_wh_ratio: l_float32,
        max_ht_ratio: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassIndex(
        recog: *mut L_RECOG,
        val: l_int32,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogStringToIndex(
        recog: *mut L_RECOG,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassString(
        recog: *mut L_RECOG,
        index: l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_convertCharstrToInt(str_: *const ::std::os::raw::c_char, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn recogRead(filename: *const ::std::os::raw::c_char) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadStream(fp: *mut FILE) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadMem(data: *const l_uint8, size: size_t) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogWrite(filename: *const ::std::os::raw::c_char, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteStream(fp: *mut FILE, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, recog: *mut L_RECOG)
        -> l_ok;
}
extern "C" {
    pub fn recogExtractPixa(recog: *mut L_RECOG) -> *mut PIXA;
}
extern "C" {
    pub fn recogDecode(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        nlevels: l_int32,
        ppixdb: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn recogCreateDid(recog: *mut L_RECOG, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogDestroyDid(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogDidExists(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogGetDid(recog: *mut L_RECOG) -> *mut L_RDID;
}
extern "C" {
    pub fn recogSetChannelParams(recog: *mut L_RECOG, nlevels: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyMultiple(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdb: *mut *mut PIX,
        debugsplit: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogSplitIntoCharacters(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestRow(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pboxa: *mut *mut BOXA,
        pnascore: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        psachar: *mut *mut SARRAY,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestChar(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pbox: *mut *mut BOX,
        pscore: *mut l_float32,
        pindex: *mut l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPixa(recog: *mut L_RECOG, pixa: *mut PIXA, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPix(recog: *mut L_RECOG, pixs: *mut PIX, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogSkipIdentify(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn rchaDestroy(prcha: *mut *mut L_RCHA);
}
extern "C" {
    pub fn rchDestroy(prch: *mut *mut L_RCH);
}
extern "C" {
    pub fn rchaExtract(
        rcha: *mut L_RCHA,
        pnaindex: *mut *mut NUMA,
        pnascore: *mut *mut NUMA,
        psatext: *mut *mut SARRAY,
        pnasample: *mut *mut NUMA,
        pnaxloc: *mut *mut NUMA,
        pnayloc: *mut *mut NUMA,
        pnawidth: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn rchExtract(
        rch: *mut L_RCH,
        pindex: *mut l_int32,
        pscore: *mut l_float32,
        ptext: *mut *mut ::std::os::raw::c_char,
        psample: *mut l_int32,
        pxloc: *mut l_int32,
        pyloc: *mut l_int32,
        pwidth: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessToIdentify(recog: *mut L_RECOG, pixs: *mut PIX, pad: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn recogExtractNumbers(
        recog: *mut L_RECOG,
        boxas: *mut BOXA,
        scorethresh: l_float32,
        spacethresh: l_int32,
        pbaa: *mut *mut BOXAA,
        pnaa: *mut *mut NUMAA,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn showExtractNumbers(
        pixs: *mut PIX,
        sa: *mut SARRAY,
        baa: *mut BOXAA,
        naa: *mut NUMAA,
        ppixdb: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        ppix: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogAddSample(recog: *mut L_RECOG, pix: *mut PIX, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogModifyTemplate(recog: *mut L_RECOG, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn recogAverageSamples(recog: *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAccumulateSamples(
        pixa: *mut PIXA,
        pta: *mut PTA,
        ppixd: *mut *mut PIX,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogTrainingFinished(
        precog: *mut *mut L_RECOG,
        modifyflag: l_int32,
        minsize: l_int32,
        minfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogFilterPixaBySize(
        pixas: *mut PIXA,
        setsize: l_int32,
        maxkeep: l_int32,
        max_ht_ratio: l_float32,
        pna: *mut *mut NUMA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogSortPixaByClass(pixa: *mut PIXA, setsize: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn recogRemoveOutliers1(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers1(
        pixas: *mut PIXA,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogRemoveOutliers2(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers2(
        pixas: *mut PIXA,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainFromBoot(
        recogboot: *mut L_RECOG,
        pixas: *mut PIXA,
        minscore: l_float32,
        threshold: l_int32,
        debug: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogPadDigitTrainingSet(
        precog: *mut *mut L_RECOG,
        scaleh: l_int32,
        linew: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIsPaddingNeeded(recog: *mut L_RECOG, psa: *mut *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn recogAddDigitPadTemplates(recog: *mut L_RECOG, sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn recogMakeBootDigitRecog(
        nsamp: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        maxyshift: l_int32,
        debug: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogMakeBootDigitTemplates(nsamp: l_int32, debug: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn recogShowContent(
        fp: *mut FILE,
        recog: *mut L_RECOG,
        index: l_int32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogDebugAverages(recog: *mut L_RECOG, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogShowAverageTemplates(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogShowMatchesInRange(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        minscore: l_float32,
        maxscore: l_float32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogShowMatch(
        recog: *mut L_RECOG,
        pix1: *mut PIX,
        pix2: *mut PIX,
        box_: *mut BOX,
        index: l_int32,
        score: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn regTestSetup(
        argc: l_int32,
        argv: *mut *mut ::std::os::raw::c_char,
        prp: *mut *mut L_REGPARAMS,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCleanup(rp: *mut L_REGPARAMS) -> l_ok;
}
extern "C" {
    pub fn regTestCompareValues(
        rp: *mut L_REGPARAMS,
        val1: l_float32,
        val2: l_float32,
        delta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCompareStrings(
        rp: *mut L_REGPARAMS,
        string1: *mut l_uint8,
        bytes1: size_t,
        string2: *mut l_uint8,
        bytes2: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestComparePix(rp: *mut L_REGPARAMS, pix1: *mut PIX, pix2: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn regTestCompareSimilarPix(
        rp: *mut L_REGPARAMS,
        pix1: *mut PIX,
        pix2: *mut PIX,
        mindiff: l_int32,
        maxfract: l_float32,
        printstats: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCheckFile(rp: *mut L_REGPARAMS, localname: *const ::std::os::raw::c_char)
        -> l_ok;
}
extern "C" {
    pub fn regTestCompareFiles(rp: *mut L_REGPARAMS, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWritePixAndCheck(rp: *mut L_REGPARAMS, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWriteDataAndCheck(
        rp: *mut L_REGPARAMS,
        data: *mut ::std::os::raw::c_void,
        nbytes: size_t,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestGenLocalFilename(
        rp: *mut L_REGPARAMS,
        index: l_int32,
        format: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixRasterop(
        pixd: *mut PIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropVip(
        pixd: *mut PIX,
        bx: l_int32,
        bw: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropHip(
        pixd: *mut PIX,
        by: l_int32,
        bh: l_int32,
        hshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixTranslate(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRasteropIP(
        pixd: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropFullImage(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn rasteropUniLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
    );
}
extern "C" {
    pub fn rasteropLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        datas: *mut l_uint32,
        spixw: l_int32,
        spixh: l_int32,
        swpl: l_int32,
        sx: l_int32,
        sy: l_int32,
    );
}
extern "C" {
    pub fn rasteropVipLow(
        data: *mut l_uint32,
        pixw: l_int32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        x: l_int32,
        w: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn rasteropHipLow(
        data: *mut l_uint32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        y: l_int32,
        h: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn pixRotate(
        pixs: *mut PIX,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEmbedForRotation(
        pixs: *mut PIX,
        angle: l_float32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBySampling(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBinaryNice(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateWithAlpha(
        pixs: *mut PIX,
        angle: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAM(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColor(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGray(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMCorner(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorCorner(pixs: *mut PIX, angle: l_float32, fillval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGrayCorner(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorFast(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateOrth(pixs: *mut PIX, quads: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate180(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate90(pixs: *mut PIX, direction: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipLR(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipTB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate2Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate3Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearIP(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRotateShearCenter(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearCenterIP(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixStrokeWidthTransform(
        pixs: *mut PIX,
        color: l_int32,
        depth: l_int32,
        nangles: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunlengthTransform(
        pixs: *mut PIX,
        color: l_int32,
        direction: l_int32,
        depth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHorizontalRuns(
        pix: *mut PIX,
        y: l_int32,
        xstart: *mut l_int32,
        xend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindVerticalRuns(
        pix: *mut PIX,
        x: l_int32,
        ystart: *mut l_int32,
        yend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxRuns(pix: *mut PIX, direction: l_int32, pnastart: *mut *mut NUMA)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindMaxHorizontalRunOnLine(
        pix: *mut PIX,
        y: l_int32,
        pxstart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxVerticalRunOnLine(
        pix: *mut PIX,
        x: l_int32,
        pystart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn runlengthMembershipOnLine(
        buffer: *mut l_int32,
        size: l_int32,
        depth: l_int32,
        start: *mut l_int32,
        end: *mut l_int32,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeMSBitLocTab(bitval: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn sarrayCreate(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateInitialized(
        n: l_int32,
        initstr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateWordsFromString(string: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateLinesFromString(
        string: *const ::std::os::raw::c_char,
        blankflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayDestroy(psa: *mut *mut SARRAY);
}
extern "C" {
    pub fn sarrayCopy(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayClone(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayAddString(
        sa: *mut SARRAY,
        string: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayRemoveString(sa: *mut SARRAY, index: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayReplaceString(
        sa: *mut SARRAY,
        index: l_int32,
        newstr: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayClear(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayGetCount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetArray(
        sa: *mut SARRAY,
        pnalloc: *mut l_int32,
        pn: *mut l_int32,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetString(
        sa: *mut SARRAY,
        index: l_int32,
        copyflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToString(sa: *mut SARRAY, addnlflag: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToStringRange(
        sa: *mut SARRAY,
        first: l_int32,
        nstrings: l_int32,
        addnlflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayConcatUniformly(sa: *mut SARRAY, n: l_int32, addnlflag: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayJoin(sa1: *mut SARRAY, sa2: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppendRange(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        start: l_int32,
        end: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayPadToSameSize(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        padstring: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertWordsToLines(sa: *mut SARRAY, linesize: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySplitString(
        sa: *mut SARRAY,
        str_: *const ::std::os::raw::c_char,
        separators: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarraySelectBySubstring(
        sain: *mut SARRAY,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySelectRange(sain: *mut SARRAY, first: l_int32, last: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayParseRange(
        sa: *mut SARRAY,
        start: l_int32,
        pactualstart: *mut l_int32,
        pend: *mut l_int32,
        pnewstart: *mut l_int32,
        substr: *const ::std::os::raw::c_char,
        loc: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRead(filename: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadStream(fp: *mut FILE) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadMem(data: *const l_uint8, size: size_t) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayWrite(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStream(fp: *mut FILE, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStderr(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppend(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn getNumberedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getSortedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn convertSortedToNumberedPathnames(
        sa: *mut SARRAY,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getFilenamesInDirectory(dirname: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySort(saout: *mut SARRAY, sain: *mut SARRAY, sortorder: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySortByIndex(sain: *mut SARRAY, naindex: *mut NUMA) -> *mut SARRAY;
}
extern "C" {
    pub fn stringCompareLexical(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_asetCreateFromSarray(sa: *mut SARRAY) -> *mut L_ASET;
}
extern "C" {
    pub fn sarrayRemoveDupsByAset(sas: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByAset(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromSarray(sa: *mut SARRAY) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn sarrayRemoveDupsByHmap(
        sas: *mut SARRAY,
        psad: *mut *mut SARRAY,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByHmap(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByHmap(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayGenerateIntegers(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayLookupCSKV(
        sa: *mut SARRAY,
        keystring: *const ::std::os::raw::c_char,
        pvalstring: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScale(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSizeRel(pixs: *mut PIX, delw: l_int32, delh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToResolution(
        pixs: *mut PIX,
        target: l_float32,
        assumed: l_float32,
        pscalefact: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGeneral(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        sharpfract: l_float32,
        sharpwidth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColorLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySampling(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySamplingToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleByIntSampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGrayFast(pixs: *mut PIX, factor: l_int32, color: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmooth(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmoothToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGray2(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMapToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBinary(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayFast(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray3(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray6(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayMipmap(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleMipmap(pixs1: *mut PIX, pixs2: *mut PIX, scale: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandReplicate(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax(
        pixs: *mut PIX,
        xfact: l_int32,
        yfact: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax2(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRankCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRank2(pixs: *mut PIX, rank: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScaleWithAlpha(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinary(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinaryRestricted(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        xmax: l_int32,
        ymax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHolesByFilling(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillClosedBorders(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillBgFromBorder(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillHolesToBoundingRect(
        pixs: *mut PIX,
        minsize: l_int32,
        maxhfract: l_float32,
        minfgfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillGray(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInv(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGraySimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInvSimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayBasin(
        pixb: *mut PIX,
        pixm: *mut PIX,
        delta: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDistanceFunction(
        pixs: *mut PIX,
        connectivity: l_int32,
        outdepth: l_int32,
        boundcond: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedspread(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixLocalExtrema(
        pixs: *mut PIX,
        maxmin: l_int32,
        minmax: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectedLocalExtrema(
        pixs: *mut PIX,
        mindist: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindEqualValues(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectMinInConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        ppta: *mut *mut PTA,
        pnav: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRemoveSeededComponents(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        bordersize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaCreate(n: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn selaDestroy(psela: *mut *mut SELA);
}
extern "C" {
    pub fn selCreate(
        height: l_int32,
        width: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selDestroy(psel: *mut *mut SEL);
}
extern "C" {
    pub fn selCopy(sel: *mut SEL) -> *mut SEL;
}
extern "C" {
    pub fn selCreateBrick(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        type_: l_int32,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateComb(factor1: l_int32, factor2: l_int32, direction: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn create2dIntArray(sy: l_int32, sx: l_int32) -> *mut *mut l_int32;
}
extern "C" {
    pub fn selaAddSel(
        sela: *mut SELA,
        sel: *mut SEL,
        selname: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetCount(sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaGetSel(sela: *mut SELA, i: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selGetName(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selSetName(sel: *mut SEL, name: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn selaFindSelByName(
        sela: *mut SELA,
        name: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
        psel: *mut *mut SEL,
    ) -> l_ok;
}
extern "C" {
    pub fn selGetElement(sel: *mut SEL, row: l_int32, col: l_int32, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selSetElement(sel: *mut SEL, row: l_int32, col: l_int32, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetParameters(
        sel: *mut SEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selSetOrigin(sel: *mut SEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetTypeAtOrigin(sel: *mut SEL, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selaGetBrickName(
        sela: *mut SELA,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaGetCombName(
        sela: *mut SELA,
        size: l_int32,
        direction: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getCompositeParameters(
        size: l_int32,
        psize1: *mut l_int32,
        psize2: *mut l_int32,
        pnameh1: *mut *mut ::std::os::raw::c_char,
        pnameh2: *mut *mut ::std::os::raw::c_char,
        pnamev1: *mut *mut ::std::os::raw::c_char,
        pnamev2: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetSelnames(sela: *mut SELA) -> *mut SARRAY;
}
extern "C" {
    pub fn selFindMaxTranslations(
        sel: *mut SEL,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
        pxn: *mut l_int32,
        pyn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selRotateOrth(sel: *mut SEL, quads: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selaRead(fname: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selaReadStream(fp: *mut FILE) -> *mut SELA;
}
extern "C" {
    pub fn selRead(fname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selReadStream(fp: *mut FILE) -> *mut SEL;
}
extern "C" {
    pub fn selaWrite(fname: *const ::std::os::raw::c_char, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selaWriteStream(fp: *mut FILE, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selWrite(fname: *const ::std::os::raw::c_char, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selWriteStream(fp: *mut FILE, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selCreateFromString(
        text: *const ::std::os::raw::c_char,
        h: l_int32,
        w: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selPrintToString(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selCreateFromPta(
        pta: *mut PTA,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromPix(
        pix: *mut PIX,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selReadFromColorImage(pathname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromColorPix(
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selaCreateFromColorPixa(pixa: *mut PIXA, sa: *mut SARRAY) -> *mut SELA;
}
extern "C" {
    pub fn selDisplayInPix(sel: *mut SEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn selaDisplayInPix(
        sela: *mut SELA,
        size: l_int32,
        gthick: l_int32,
        spacing: l_int32,
        ncols: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaAddBasic(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddHitMiss(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaLinear(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaCombs(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddCrossJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn selaAddTJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn sela4ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela4and8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selMakePlusSign(size: l_int32, linewidth: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelWithRuns(
        pixs: *mut PIX,
        nhlines: l_int32,
        nvlines: l_int32,
        distance: l_int32,
        minlength: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelRandom(
        pixs: *mut PIX,
        hitfract: l_float32,
        missfract: l_float32,
        distance: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelBoundary(
        pixs: *mut PIX,
        hitdist: l_int32,
        missdist: l_int32,
        hitskip: l_int32,
        missskip: l_int32,
        topflag: l_int32,
        botflag: l_int32,
        leftflag: l_int32,
        rightflag: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGetRunCentersOnLine(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        minlength: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRunsOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSubsampleBoundaryPixels(pixs: *mut PIX, skip: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn adjacentOnPixelInRaster(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        pxa: *mut l_int32,
        pya: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayHitMissSel(
        pixs: *mut PIX,
        sel: *mut SEL,
        scalefactor: l_int32,
        hitcolor: l_uint32,
        misscolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearIP(pixs: *mut PIX, yloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixVShearIP(pixs: *mut PIX, xloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixHShearLI(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearLI(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewBoth(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskew(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkewAndDeskew(
        pixs: *mut PIX,
        redsearch: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewGeneral(
        pixs: *mut PIX,
        redsweep: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        redsearch: l_int32,
        thresh: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkew(pixs: *mut PIX, pangle: *mut l_float32, pconf: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweep(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        reduction: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearch(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScore(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScorePivot(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pivot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewOrthogonalRange(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        confprior: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindDifferentialSquareSum(pixs: *mut PIX, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindNormalizedSquareSum(
        pixs: *mut PIX,
        phratio: *mut l_float32,
        pvratio: *mut l_float32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamSpix(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderSpix(
        filename: *const ::std::os::raw::c_char,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderSpix(
        fp: *mut FILE,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sreadHeaderSpix(
        data: *const l_uint32,
        size: size_t,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamSpix(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemSpix(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemSpix(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSerializeToMemory(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint32,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDeserializeFromMemory(data: *const l_uint32, nbytes: size_t) -> *mut PIX;
}
extern "C" {
    pub fn lstackCreate(n: l_int32) -> *mut L_STACK;
}
extern "C" {
    pub fn lstackDestroy(plstack: *mut *mut L_STACK, freeflag: l_int32);
}
extern "C" {
    pub fn lstackAdd(lstack: *mut L_STACK, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lstackRemove(lstack: *mut L_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lstackGetCount(lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn lstackPrint(fp: *mut FILE, lstack: *mut L_STACK) -> l_ok;
}
extern "C" {
    pub fn strcodeCreate(fileno: l_int32) -> *mut L_STRCODE;
}
extern "C" {
    pub fn strcodeCreateFromFile(
        filein: *const ::std::os::raw::c_char,
        fileno: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeGenerate(
        strcode: *mut L_STRCODE,
        filein: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeFinalize(
        pstrcode: *mut *mut L_STRCODE,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getStructStrFromFile(
        filename: *const ::std::os::raw::c_char,
        field: l_int32,
        pstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeLength(pixs: *mut PIX, tab8: *mut l_int32, plength: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFindStrokeWidth(
        pixs: *mut PIX,
        thresh: l_float32,
        tab8: *mut l_int32,
        pwidth: *mut l_float32,
        pnahisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindStrokeWidth(
        pixa: *mut PIXA,
        thresh: l_float32,
        tab8: *mut l_int32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaModifyStrokeWidth(pixas: *mut PIXA, targetw: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixModifyStrokeWidth(pixs: *mut PIX, width: l_float32, targetw: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSetStrokeWidth(
        pixas: *mut PIXA,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSetStrokeWidth(
        pixs: *mut PIX,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn sudokuReadFile(filename: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuReadString(str_: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuCreate(array: *mut l_int32) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuDestroy(psud: *mut *mut L_SUDOKU);
}
extern "C" {
    pub fn sudokuSolve(sud: *mut L_SUDOKU) -> l_int32;
}
extern "C" {
    pub fn sudokuTestUniqueness(array: *mut l_int32, punique: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn sudokuGenerate(
        array: *mut l_int32,
        seed: l_int32,
        minelems: l_int32,
        maxtries: l_int32,
    ) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuOutput(sud: *mut L_SUDOKU, arraytype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAddSingleTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
        poverflow: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddTextlines(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        wtext: l_int32,
        firstindent: l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetTextline(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        pwidth: *mut l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaAddTextNumber(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        na: *mut NUMA,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddTextlines(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        sa: *mut SARRAY,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPixWithText(
        pixa: *mut PIXA,
        pixs: *mut PIX,
        reduction: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfGetLineStrings(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        maxw: l_int32,
        firstindent: l_int32,
        ph: *mut l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn bmfGetWordWidths(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bmfGetStringWidth(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn splitStringToParagraphs(
        textstr: *mut ::std::os::raw::c_char,
        splitflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadTiff(filename: *const ::std::os::raw::c_char, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamTiff(fp: *mut FILE, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteTiff(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteTiffCustom(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiff(fp: *mut FILE, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiffWA(
        fp: *mut FILE,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadFromMultipageTiff(
        fname: *const ::std::os::raw::c_char,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMultipageTiff(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMultipageTiff(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiff(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiffSA(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn fprintTiffInfo(fpout: *mut FILE, tiffile: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn tiffGetCount(fp: *mut FILE, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getTiffResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn readHeaderTiff(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderTiff(
        fp: *mut FILE,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemTiff(
        cdata: *const l_uint8,
        size: size_t,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findTiffCompression(fp: *mut FILE, pcomptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn extractG4DataFromFile(
        filein: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pminisblack: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemTiff(cdata: *const l_uint8, size: size_t, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemFromMultipageTiff(
        cdata: *const l_uint8,
        size: size_t,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMemMultipageTiff(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMemMultipageTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixa: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiffCustom(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn setMsgSeverity(newsev: l_int32) -> l_int32;
}
extern "C" {
    pub fn returnErrorInt(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        ival: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn returnErrorFloat(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        fval: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn returnErrorPtr(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        pval: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn leptSetStderrHandler(
        handler: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn lept_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn filesAreIdentical(
        fname1: *const ::std::os::raw::c_char,
        fname2: *const ::std::os::raw::c_char,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertOnLittleEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnBigEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnLittleEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertOnBigEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn fileCorruptByDeletion(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCorruptByMutation(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileReplaceBytes(
        filein: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
        newdata: *mut l_uint8,
        newsize: size_t,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn genRandomIntOnInterval(
        start: l_int32,
        end: l_int32,
        seed: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn lept_roundftoi(fval: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_hashStringToUint64(str_: *const ::std::os::raw::c_char, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashStringToUint64Fast(
        str_: *const ::std::os::raw::c_char,
        phash: *mut l_uint64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hashPtToUint64(x: l_int32, y: l_int32, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashFloat64ToUint64(val: l_float64, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn findNextLargerPrime(start: l_int32, pprime: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn lept_isPrime(n: l_uint64, pis_prime: *mut l_int32, pfactor: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn convertIntToGrayCode(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertGrayCodeToInt(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn getLeptonicaVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn startTimer();
}
extern "C" {
    pub fn stopTimer() -> l_float32;
}
extern "C" {
    pub fn startTimerNested() -> L_TIMER;
}
extern "C" {
    pub fn stopTimerNested(rusage_start: L_TIMER) -> l_float32;
}
extern "C" {
    pub fn l_getCurrentTime(sec: *mut l_int32, usec: *mut l_int32);
}
extern "C" {
    pub fn startWallTimer() -> *mut L_WALLTIMER;
}
extern "C" {
    pub fn stopWallTimer(ptimer: *mut *mut L_WALLTIMER) -> l_float32;
}
extern "C" {
    pub fn l_getFormattedDate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringNew(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringCopy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCopySegment(
        src: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplace(
        pdest: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringLength(src: *const ::std::os::raw::c_char, size: size_t) -> l_int32;
}
extern "C" {
    pub fn stringCat(
        dest: *mut ::std::os::raw::c_char,
        size: size_t,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringConcatNew(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoin(
        src1: *const ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoinIP(
        psrc1: *mut *mut ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringReverse(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtokSafe(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        psaveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringSplitOnToken(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        phead: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCheckForChars(
        src: *const ::std::os::raw::c_char,
        chars: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringRemoveChars(
        src: *const ::std::os::raw::c_char,
        remchars: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pcount: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
        pfound: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringFindEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn stringFindSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn arrayReplaceEachSequence(
        datas: *const l_uint8,
        dataslen: size_t,
        seq: *const l_uint8,
        seqlen: size_t,
        newseq: *const l_uint8,
        newseqlen: size_t,
        pdatadlen: *mut size_t,
        pcount: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn arrayFindEachSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn arrayFindSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
        poffset: *mut l_int32,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn reallocNew(
        pindata: *mut *mut ::std::os::raw::c_void,
        oldsize: size_t,
        newsize: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn l_binaryRead(
        filename: *const ::std::os::raw::c_char,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadStream(fp: *mut FILE, pnbytes: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelect(
        filename: *const ::std::os::raw::c_char,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelectStream(
        fp: *mut FILE,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryWrite(
        filename: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn nbytesInFile(filename: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn fnbytesInFile(fp: *mut FILE) -> size_t;
}
extern "C" {
    pub fn l_binaryCopy(datas: *const l_uint8, size: size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryCompare(
        data1: *const l_uint8,
        size1: size_t,
        data2: *const l_uint8,
        size2: size_t,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCopy(
        srcfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileConcatenate(
        srcfile: *const ::std::os::raw::c_char,
        destfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileAppendString(
        filename: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileSplitLinesUniform(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        save_empty: l_int32,
        rootpath: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fopenReadStream(filename: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteStream(
        filename: *const ::std::os::raw::c_char,
        modestring: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopenReadFromMemory(data: *const l_uint8, size: size_t) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteWinTempfile() -> *mut FILE;
}
extern "C" {
    pub fn lept_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn lept_fclose(fp: *mut FILE) -> l_ok;
}
extern "C" {
    pub fn lept_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lept_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lept_mkdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_rmdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_direxists(dir: *const ::std::os::raw::c_char, pexists: *mut l_int32);
}
extern "C" {
    pub fn lept_rm_match(
        subdir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rm(
        subdir: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rmfile(filepath: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_mv(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_cp(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn callSystemDebug(cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn splitPathAtDirectory(
        pathname: *const ::std::os::raw::c_char,
        pdir: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn splitPathAtExtension(
        pathname: *const ::std::os::raw::c_char,
        pbasename: *mut *mut ::std::os::raw::c_char,
        pextension: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pathJoin(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn appendSubdirs(
        basedir: *const ::std::os::raw::c_char,
        subdirs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertSepCharsInPath(path: *mut ::std::os::raw::c_char, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn genPathname(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn makeTempDirname(
        result: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        subdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn modifyTrailingSlash(
        path: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        flag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_makeTempFilename() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn extractNumberFromFilename(
        fname: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleCaptcha(
        pixs: *mut PIX,
        border: l_int32,
        nterms: l_int32,
        seed: l_uint32,
        color: l_uint32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRandomHarmonicWarp(
        pixs: *mut PIX,
        xmag: l_float32,
        ymag: l_float32,
        xfreq: l_float32,
        yfreq: l_float32,
        nx: l_int32,
        ny: l_int32,
        seed: l_uint32,
        grayval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWarpStereoscopic(
        pixs: *mut PIX,
        zbend: l_int32,
        zshiftt: l_int32,
        zshiftb: l_int32,
        ybendt: l_int32,
        ybendb: l_int32,
        redleft: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontal(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalSampled(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalLI(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShear(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearSampled(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearLI(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStereoFromPair(
        pix1: *mut PIX,
        pix2: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn wshedCreate(
        pixs: *mut PIX,
        pixm: *mut PIX,
        mindepth: l_int32,
        debugflag: l_int32,
    ) -> *mut L_WSHED;
}
extern "C" {
    pub fn wshedDestroy(pwshed: *mut *mut L_WSHED);
}
extern "C" {
    pub fn wshedApply(wshed: *mut L_WSHED) -> l_ok;
}
extern "C" {
    pub fn wshedBasins(
        wshed: *mut L_WSHED,
        ppixa: *mut *mut PIXA,
        pnalevels: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn wshedRenderFill(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn wshedRenderColors(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn pixaWriteWebPAnim(
        filename: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStreamWebPAnim(
        fp: *mut FILE,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMemWebPAnim(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamWebP(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemWebP(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderWebP(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemWebP(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteWebP(
        filename: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamWebP(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemWebP(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_jpegSetQuality(new_quality: l_int32) -> l_int32;
}
extern "C" {
    pub fn setLeptDebugOK(allow: l_int32);
}
extern "C" {
    pub fn pixaWriteFiles(
        rootname: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteDebug(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWrite(fname: *const ::std::os::raw::c_char, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteAutoFormat(filename: *const ::std::os::raw::c_char, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStream(fp: *mut FILE, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteImpliedFormat(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixChooseOutputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn getImpliedFileFormat(filename: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixGetAutoFormat(pix: *mut PIX, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getFormatExtension(format: l_int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_fileDisplay(
        fname: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplay(pixs: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayWithTitle(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        title: *const ::std::os::raw::c_char,
        dispflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeColorSquare(
        color: l_uint32,
        size: l_int32,
        addlabel: l_int32,
        location: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_chooseDisplayProg(selection: l_int32);
}
extern "C" {
    pub fn changeFormatForMissingLib(pformat: *mut l_int32);
}
extern "C" {
    pub fn pixDisplayWrite(pixs: *mut PIX, reduction: l_int32) -> l_ok;
}
extern "C" {
    pub fn zlibCompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn zlibUncompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixa {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pix {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxa {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPix {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pta {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Box {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixaa {
    pub _address: u8,
}
